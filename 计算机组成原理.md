# 计算机组成原理

# **系统概论**

## **冯诺依曼结构计算机工作原理**

### **工作原理**

存储程序：将程序存储在计算机的存储器中；

程序控制：按指令地址访问存储器并取出指令，经译码依次产生指令执行所需的控制信号，实现对计算机的控制，完成指令的功能。



### 冯诺依曼计算机的组成（硬件+软件）

![image-20220813181234342](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20220813181234342.png)



#### **硬件系统**

##### 运算器

负责算术运算（加减乘除等）、逻辑运算（与或非 位移等）。

基本结构：ALU（Arithmetic Logical unit）、寄存器、连接通路

![image-20220813181728433](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20220813181728433.png)



##### **控制器**

基本功能：产生指令执行过程所需要的所有控制信号，控制相关功能部件执行相应操作

控制信号的形式：电平信号、脉冲信号

产生控制信号的依据：指令、状态、时序

控制信号的产生方式：微程序、硬布线

![image-20220813182042842](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20220813182042842.png)



##### **存储器**

功能：存储原程序、原数据、运算中间结果

工作模式：读/写；

工作原理：按地址访问，读/写数据。

![image-20220813182404850](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20220813182404850.png)

容量--->地址线数量

1K ----> 10

1M ----> 20

1G ----> 30

q：要访问256G的主存空间，至少需要多少地址线？

a：

​	1024Byte(字节)=1kB

​	1024kB=1MB

​	1024MB=1GB

​	1024=2^10^

​	1GB=2^30^B

​	内存容量2^n^字节-->地址总线n根

​	256GB=2^38^字节-->地址总线38根



##### **输入输出设备**

输入设备：向计算机输入数据（键盘、鼠标、网卡、扫描仪等）

输出设备：输出处理结果（显示器、声卡、网卡、打印机等）



#### **软件系统**

对于软件的理解：

- 可运行的思想和内容的数字化

  思想：算法、规律、方法----程序表达

  内容：图形、图像、数据、声音文字等被处理的对象

- 软件的表现形式：程序和数据（以二进制表示的信息）

- 软件的核心：算法



![image-20220813183243850](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20220813183243850.png)

- 系统软件

  操作系统、网络系统、编译系统等

- 支持软件

  开发工具、界面工具等

- 应用软件

  游戏软件、办公软件等



### **计算机的层次结构**

<img src="https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20220813183518988.png" alt="image-20220813183518988" style="zoom:50%;" />

指令集架构层为硬件和软件的分界线



## **计算机系统性能评价**

### **非时间指标**

1. 机器字长：指机器一次能处理的二进制位数

   - 由加法器、寄存器的位数决定；
   - 一般与内部寄存器和位数相等（字长）
   - 字长越长，表示数据的范围就越大，精确度越高；
   - 目前常见的有32位和64位

2. 总线宽度：数据总线一次能并行转送的最大信息的位数

   - 一般指运算器与存储器之间的数据总线位数。
   - 有些计算机内部与外部数据总线宽度不一致
   - 8086、80286、 80386内外数据总线等宽
   - 8088、80386SX 外部总线宽度8位内部总线宽度16位
   - Pentium外总线64位,内总线32位（两条32位流水线）

   ![image-20220813192003616](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20220813192003616.png)

3. 主存容量与存储带宽

   - 主存容量：是指一台计算机主存所包含的存储单元总数。
   - 存储带宽：指单位时间内与主存交换的二进制信息量，常用单位B/S(字节/秒)。（影响存储带宽的指标包括数据位宽和数据传输速率）。



### **时间指标**

#### **主频f/时钟周期T，外频、倍频**

- 主频f：指CPU内核工作的时钟频率，即CPU内数字脉冲信号振荡的速率，与CPU实际的运算能力之间不是唯一的、直接关系

- 时钟周期T：也称节拍周期，是计算机中最基本、最小的时间单位。在一个时钟周期内，CPU仅完成一个最基本的动作；

  > f与T的关系：
  >
  > 互为倒数，f越高，T就越小（f=100MHz时T=10ns， f=1GHz时T=1ns）

- 外频：指CPU（内存）与主板之间同步的时钟频率（系统总线的工作频率）；

- 倍频：CPU主频与外频之间的倍数；

  > 主频=外频×倍频



#### **CPI**

Clock cycles Per Instruction

执行一条指令（平均）需要的时钟周期数（即T周期的个数）

可有多个维度如单条指令CPI、一段程序中所有指令的CPI、指令系统CPI等

IPC（Instruction Per Clock） 每个时钟周期内执行的指令条数（并行）



$$CPI = \frac{ 程序中所有指令的时钟周期数之和}{程序指令总数} = \sum (程序中各类指令的CPI × 程序中该类指令的比列)$$

 

应用举例：

> 某计算机指令系统中各类指令所占比例及CPI如下表所示，求程序的CPI

|   指令类型    | CPI  | 指令比例 |
| :-----------: | :--: | :------: |
|  算术和逻辑   |  1   |   60%    |
|  Load/Store   |  2   |   18%    |
|     转移      |  4   |   12%    |
| Cache缺失访问 |  8   |   10%    |

解：$CPI = 1×60\% + 2×18\% + 4×12\% + 8×10\% = 2.24$

---



#### **MIPS**

Million Instrucitons Per Second

每秒钟CPU能执行的指令总条数（单位：百万秒/条）

$$MIPS = \frac{ 指令条数}{执行时间 × 10^6} 
= \frac{指令条数}{(所有指令CPU时钟周期数之和/f)×10^6}
= \frac{f}{CPI ×10^6}$$

应用举例：

> 某计算机主频为1GHZ，在其上运行的目标代码包含2×10^5^条指令，分4类，各类指令所占比例和各自CPI如下表所示，求程序的MIPS。

|   指令类型    | CPI  | 指令比例 |
| :-----------: | :--: | :------: |
|  算术和逻辑   |  1   |   60%    |
|  Load/Store   |  2   |   18%    |
|     转移      |  4   |   12%    |
| Cache缺失访问 |  8   |   10%    |

解：根据CPU全性能公式：$MIPS = \frac{f}{CPI ×10^6}$

$CPI = 1×60\% + 2×18\% + 4 ×12\% + 8×10\% = 2.24$

$MIPS = \frac{f}{(CPI × 10^6)} = \frac{1×10^9}{(2.24×10^6)} = 446.4$

---



#### **CPU时间**

执行一段程序所需的时间 = （CPU时间 + I/O时间 + 存储访问时间 + 各类排队时延等）。

CPU时间 = 程序中所有指令的时钟周期数之和 × T = 程序中所有指令的时钟周期数之和 / f

CPU时间的计算方法：

- 考虑CPI后的CPU时间

  $$CPU时间=总指令数×\sum_{i=1}^n(CPI_I×\frac{IC_i}{总指令数})×时钟周期时间=总指令数×CPI×T$$

- 考虑MIPS后的CPU时间

  $$MIPS = \frac{指令数量}{指令执行时间 × 10^6}$$

  $$程序的执行时间 t=\frac{指令数量}{MIPS×10^6}$$



应用举例：

> 某计算机主屏为1GHZ，在其上运行的目标代码包含2×10^5^条指令，分4类，各类指令所占比例和各自CPI如下表所示，求该段程序的CPU时间。

|   指令类型    | CPI  | 指令比例 |
| :-----------: | :--: | :------: |
|  算术和逻辑   |  1   |   60%    |
|  Load/Store   |  2   |   18%    |
|     转移      |  4   |   12%    |
| Cache缺失访问 |  8   |   10%    |

方法一：利用CPI

$CPU时间 = 2 × 10^5 × \frac{CPI}{f}= (2 × 10^5× 2.24 \div 10^9) = 4.48 × 10^{-4}(秒)$

ps:主频f和周期T互为倒数

方法二：利用MIPS

$CPU时间 = \frac{指令数量}{MIPS × 10^6} = \frac{2 × 10^5} {\frac{10^3}{2.24} × 10 ^{-4}} = 4.48 ×10^{-4} (秒)$

---



#### **计算机性能指标是确定的吗？**

![image-20220815205947449](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20220815205947449.png)



## **计算机性能测试**

### **CPU测试工具**

- CPUmark：综合CPU测试，包括系统存储，浮点运算和逻辑运算；
- SysID：测试CPU电压，运行频率，L1、L2 Cache以及各项技术资料；
- Hot CPU Tester：可测试机器稳定性，尤其是超频后的稳定性，找出CPU的最高超频点或缺陷，还可检测CPU的详细性能指标并给出量化的分数值。包括「复杂矩阵」「排序算法」「快速傅立叶变换」 「CPU 缓存」「内存」「硬盘」 及指令集等。另外其CPU/Mem Burn-in )还可以作为新购机时的烤机软件来使用。



### **显卡测试工具**

- 3DMark：除衡量显卡性能外，已渐渐转变成一款衡量整机性能的软件，已发行3Dmark99、3Dmark 1 1和The new 3DMark等近10个版本；
- N-Bench2：重点测试CPU以及系统图形性能；
- FurMark：通过皮毛渲染算法来衡量显卡的性能及其稳定性, 提供了全屏/窗口、预定分辨率、基于时间或帧的测试、多种多重采样反锯齿、竞赛等多种模式。



### **硬盘测试工具**

- Hard Disk Speed：硬盘测速软件；
- Disk Benchmark：通过对不同大小的数据块对磁盘读/写速度的影响检测硬盘、U盘、 存储卡及其它可移动磁盘的读/写入速率；
- iometer：可被配置为基准测试程序的磁盘和网络I/O的负载,可测试磁盘和网络控制器的性能、总线带宽和时延等参数；
- HDD Temperature Pro:：盘温度探测软件。



### **内存测试工具**

- CTSPD：选择主板厂商及型号后可详细测试内存的信息，包括：CASlatency (列地址选通时延)、RAS to CAS delay(RAS到CAS的相对延迟时间)、RAS precharge Trp (RAS预充电时间)、 DIMM内存生产厂商和DIMM编号等信息。
- Memory Speed：通过读写不同大小的块状数据来测试内存的性能；
- Memory Transfer Timing Utility：通过对源文件和目标文件进行校正和非校正复制,测试内存的读、写速率；



# **数据表示**

## **机器数及特点**

目的：组织数据，方便计算机硬件直接使用

要考虑的因素：

- 支持的数据类型
- 能表示的数据范围
- 能表示的数据精度
- 存储和处理的代价
- 是否有利于软件的移植等



### **机器内的数据表示**

1. 真指：符号用“+”、“-”表示的数据表示方法
2. 机器数：符号数值化的数据表示方法，用0、1表示符号
3. 设定点整数的形式为X~0~X~1~X~2~X~3~....X~n~

<img src="计算机组成原理.assets/image-20220820234811931.png" alt="image-20220820234811931" style="zoom:67%;" />

---

以下内容转载自https://www.cnblogs.com/zhangziqiu/archive/2011/03/30/ComputerCode.html

**1、机器数**

一个数在计算机中的二进制表示形式, 叫做这个数的机器数。机器数是带符号的，在计算机用一个数的最高位存放符号, 正数为0, 负数为1.

比如，十进制中的数 +3 ，计算机字长为8位，转换成二进制就是00000011。如果是 -3 ，就是 10000011 。

那么，这里的 00000011 和 10000011 就是机器数。

**2、真值**

> 因为第一位是符号位，所以机器数的形式值就不等于真正的数值。例如上面的有符号数 10000011，其最高位1代表负，其真正数值是 -3 而不是形式值131（10000011转换成十进制等于131）。所以，为区别起见，将带符号位的机器数对应的真正数值称为机器数的真值。

例：0000 0001的真值 = +000 0001 = +1，1000 0001的真值 = –000 0001 = –1

 

**二. 原码, 反码, 补码的基础概念和计算方法.**

在探求为何机器要使用补码之前, 让我们先了解原码, 反码和补码的概念.对于一个数, 计算机要使用一定的编码方式进行存储. 原码, 反码, 补码是机器存储一个具体数字的编码方式.

1. 原码

原码就是符号位加上真值的绝对值, 即用第一位表示符号, 其余位表示值. 比如如果是8位二进制:

> [+1]原 = 0000 0001
>
> [-1]原 = 1000 0001

第一位是符号位. 因为第一位是符号位, 所以8位二进制数的取值范围就是:

> [1111 1111 , 0111 1111]

即

> [-127 , 127]

原码是人脑最容易理解和计算的表示方式.

**2. 反码**

反码的表示方法是:

正数的反码是其本身

负数的反码是在其原码的基础上, 符号位不变，其余各个位取反.

> [+1] = [00000001]原 = [00000001]反
>
> [-1] = [10000001]原 = [11111110]反

可见如果一个反码表示的是负数, 人脑无法直观的看出来它的数值. 通常要将其转换成原码再计算.

**3. 补码**

补码的表示方法是:

正数的补码就是其本身

负数的补码是在其原码的基础上, 符号位不变, 其余各位取反, 最后+1. (即在反码的基础上+1)

> [+1] = [00000001]原 = [00000001]反 = [00000001]补
>
> [-1] = [10000001]原 = [11111110]反 = [11111111]补

对于负数, 补码表示方式也是人脑无法直观看出其数值的. 通常也需要转换成原码在计算其数值.

 

**三. 为何要使用原码, 反码和补码**

在开始深入学习前, 我的学习建议是先"死记硬背"上面的原码, 反码和补码的表示方式以及计算方法.

现在我们知道了计算机可以有三种编码方式表示一个数. 对于正数因为三种编码方式的结果都相同:

> [+1] = [00000001]原 = [00000001]反 = [00000001]补

所以不需要过多解释. 但是对于负数:

> [-1] = [10000001]原 = [11111110]反 = [11111111]补

可见原码, 反码和补码是完全不同的. 既然原码才是被人脑直接识别并用于计算表示方式, 为何还会有反码和补码呢?

首先, 因为人脑可以知道第一位是符号位, 在计算的时候我们会根据符号位, 选择对真值区域的加减. (真值的概念在本文最开头). 但是对于计算机, 加减乘数已经是最基础的运算, 要设计的尽量简单. 计算机辨别"符号位"显然会让计算机的基础电路设计变得十分复杂! 于是人们想出了将符号位也参与运算的方法. 我们知道, 根据运算法则减去一个正数等于加上一个负数, 即: 1-1 = 1 + (-1) = 0 , 所以机器可以只有加法而没有减法, 这样计算机运算的设计就更简单了.

于是人们开始探索 将符号位参与运算, 并且只保留加法的方法. 首先来看原码:

计算十进制的表达式: 1-1=0

> 1 - 1 = 1 + (-1) = [00000001]原 + [10000001]原 = [10000010]原 = -2

如果用原码表示, 让符号位也参与计算, 显然对于减法来说, 结果是不正确的.这也就是为何计算机内部不使用原码表示一个数.

为了解决原码做减法的问题, 出现了反码:

计算十进制的表达式: 1-1=0

> 1 - 1 = 1 + (-1) = [0000 0001]原 + [1000 0001]原= [0000 0001]反 + [1111 1110]反 = [1111 1111]反 = [1000 0000]原 = -0

发现用反码计算减法, 结果的真值部分是正确的. 而唯一的问题其实就出现在"0"这个特殊的数值上. 虽然人们理解上+0和-0是一样的, 但是0带符号是没有任何意义的. 而且会有[0000 0000]原和[1000 0000]原两个编码表示0.

于是补码的出现, 解决了0的符号以及两个编码的问题:

> 1-1 = 1 + (-1) = [0000 0001]原 + [1000 0001]原 = [0000 0001]补 + [1111 1111]补 = [0000 0000]补=[0000 0000]原

这样0用[0000 0000]表示, 而以前出现问题的-0则不存在了.而且可以用[1000 0000]表示-128:

> (-1) + (-127) = [1000 0001]原 + [1111 1111]原 = [1111 1111]补 + [1000 0001]补 = [1000 0000]补

-1-127的结果应该是-128, 在用补码运算的结果中, [1000 0000]补 就是-128. 但是注意因为实际上是使用以前的-0的补码来表示-128, 所以-128并没有原码和反码表示.(对-128的补码表示[1000 0000]补算出来的原码是[0000 0000]原, 这是不正确的)

使用补码, 不仅仅修复了0的符号以及存在两个编码的问题, 而且还能够多表示一个最低数. 这就是为什么8位二进制, 使用原码或反码表示的范围为[-127, +127], 而使用补码表示的范围为[-128, 127].

因为机器使用补码, 所以对于编程中常用到的32位int类型, 可以表示范围是: [-231, 231-1] 因为第一位表示的是符号位.而使用补码表示时又可以多保存一个最小值.

---

### **常见机器数的特点**

1. 原码

   - 表示简单
   - 运算复杂：符号位不参加预算，要设置加法、减法器
   - 0的表示不唯一

2. 反码

   - 表示相对原码复杂
   - 运算相对原码简单：符号位参加运算，只需要设置加法器，但符号位的进位位需要加到最低位
   - 0的表示不唯一

3. 补码

   - 表示相对复杂
   - 运算简单：只需要设置加法器
   - 0的表示唯一

   补码中模的概念：符号位进位所在位的权值



### **移码**

移码表示浮点数的阶码

<img src="计算机组成原理.assets/image-20220821000113596.png" alt="image-20220821000113596" style="zoom:67%;" />