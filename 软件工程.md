# **软件工程**

## 软件生产周期过程分类

按**承担软件开发的主体**，将软件生存周期过程为三类：

1. 基本过程：与软件生产直接相关的活动集。
2. 支持过程：有关各方按其目的所从事的一系列支持活动集。
3. 组织过程：指那些与软件生产组织相关的活动集。

### **基本过程**

按过程中的**不同活动主体**，分为：

- 获取过程

  获取者（需方）所从事的活动和任务，目的是满足客户所表达的那些要求的产品/服务。

- 供应过程

  **供方**为了向客户提供满足需求的软件产品或服务所从事的一些列活动和任务，目的是向客服提供一个满足已达成需求的产品或服务。

- 开发过程

  **软件开发者**所从事的一系列活动和任务，其目的是将一组需求转换为一个软件产品或系统。

- 运行过程

  **系统操作者**所从事的一系列活动和任务。其目标是在软件产品预期的环境中运行该产品，并为该软件产品的维护提供支持。

- 维护过程

  **维护者**所从事的一系列的活动和任务。其目的是:对交付后的系统或软件产品，或为了纠正其错误，改进其性能或其它属性，而对其进行修改;或因环境变更，而对其进行调整。



### **支持过程**

- 文档过程

  为记录生存周期过程所产生的信息而定义的活动。

- 配置管理过程

  应用管理上的和技术上的规程来支持整个软件生存周期的过程。

- 质量保证过程

  为客观地保证软件产品和过程符合规定的需求以及已建立的计划而定义的活动。

- 验证过程

  根据软件项目需求,按不同深度（为需方、供方或某独立方)验证软件产品而定义的活动。

- 确认过程

  确认过程是一个确定需求和最终的、已建成的系统或软件产品是否满足特定预期用途的过程。

- 联合评审过程

  为评价一项活动的状态和产品而定义的活动。

- 审计过程

  确定遵照需求、计划合同的程度。

- 问题解决过程

  为分析和解决问题而定义的活动。



### 组织过程

- 管理过程

  管理过程是管理人员从事的、对其它过程进行管理的活动和任务。

- 基础设施过程

  为其他过程建立和维护所需基础设施的过程。

- 改进过程

  管理人员从事的一组活动和任务，其目的是:建立、评价、测量、控制和改进软件生存周期过程。

- 人力资源过程

  是为组织和项目提供具有技能和知识人员的过程。

- 资产管理过程

  为组织的资产管理者而定义的活动

- 复用程序管理过程

  为组织的软件复用而定义的活动。

- 领域软件工程过程

  为领域模型、领域软件体系结构的确定及该领域资产的开发和维护而定义的活动。

![软件生成周期过程分类](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/%E8%BD%AF%E4%BB%B6%E7%94%9F%E6%88%90%E5%91%A8%E6%9C%9F%E8%BF%87%E7%A8%8B%E5%88%86%E7%B1%BB.png)



## **常见软件生存周期模型**

### 瀑布模型

将软件生存周期的各项活动规定为依固定顺序而连接的若干阶段工作。

规定每一阶段的输入，以及本阶段的工作成果作为输入传入下一阶段。

<img src="https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20220416115456511.png" alt="image-20220416115456511" style="zoom:50%;" />

优点：

- 决定系统怎样做之前，存在需求阶段，**在设计之前进行规约**
- 在编码之前设计
- 每一阶段结束时复审，运行获取方和用户的参与
- 前一步工作产品可作为下一步被认可、文档化的基线。允许基线和配置早期接受控制。

缺点：

- 客户必须完整、准确、清晰的表述需求；开发人员必须一开始就理解需求
- 缺乏灵活性。若需求存在偏差会导致软件产品不能满足用户需求。
- 在项目早期过分强调基线和里程碑处的文档，可能导致花费更多时间，建立一些用处不大的文档。



### **增量模型**

该模型有一个假设，既**需求可以分段，成为一些列增量产品，每一增量可以分别开发**。

优点：

​	瀑布模型变体，拥有瀑布模型所有优点；除此之外还有：

- 第一个可交付版本所需时间和成本很少
- 开发由增量表示的小系统所承担风险小
- 第一个版本发布块，减少用户需求变更
- 允许增量投资，开项目初期，可以仅对一两个增量投资

缺点

- 如果没有对用户的变更要求进行规划，那么产生的初始增量可能会造成后来增量的不稳定
- 如果需求不想早期思考的那么稳定和完整，那么一些增量可能需要重新发布、开发
- 管理发生的成本、进度、配置的复杂性可能超出组织的能力



### **演化模型**

弹性的过程模式，由小的开发步组成，每一步历经需求、设计、实现和验证，产生软件产品的一个增量。通过迭代完成最终软件产品的开发

- 针对事先不能完整地定义需求的软件开发
- 针对用户的核心需求，开发核心系统
- 根据用户的反馈，实施活动的迭代

![image-20220416123741711](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20220416123741711.png)



### **喷泉模型**

- 特征：迭代、无缝

- 与面向对象技术的关系

![image-20220416124046352](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20220416124046352.png)



![常见软件生存周期模型](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/%E5%B8%B8%E8%A7%81%E8%BD%AF%E4%BB%B6%E7%94%9F%E5%AD%98%E5%91%A8%E6%9C%9F%E6%A8%A1%E5%9E%8B.png)



## **软件需求**

### **需求的作用**

不论是自顶向下还是还是只低向上，正确的定义问题都是解决问题的前提



#### **现代系统中软件的作用**

软件是现代系统中的重要元素，使这些产品/系统成为用户的解决方案

**软件使容易修改的，但修改正确是很难的**

软件通常是任何系统中最为复杂的部分。在系统创建时，软件的开发经常成为最大的技术挑战。



#### **软件在系统工程中的作用**

<img src="https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20220416211147784.png" alt="image-20220416211147784" style="zoom: 80%;" />

1. 需求分析（问题定义）：通过分析分配给软件的那些系统需求，确定软件需求及约束
2. 软件体系结构设计（解决方案分析）：为软件需求及约束，确定一组解决方案，进行实例研究，分析可能的方案，并选择一个最佳的一个方案
3. 验证、确认及测试（产品评估）：以需求为准则、演示、分析、及审查等方式，评估最终产品和文档。其中包括一些必要的软件系统集成活动

在任何软件开发活动中，第一步都是：

- 调查、确定一个系统需求规约中的分配给软件的那些系统需求
- 调查、确定一个软件需求规约中的软件需求

**不论是自顶向下还是还是只低向上，软件需求是软件开发的工作基础。**



### **需求的定义**

#### **定义**

一个需求是一个有关“要予构造”的陈述，描述了待开发产品/系统（或项）功能上的功能、性能参数或其他性质。

例如：

1. 系统必须有能力支持100个以上的并发用户，每个用户可以处理附录A中操作任务的任选组合，平均响应时间应该小于1秒，最大响应时间应小于5秒。

   <font color='orange'>其中：功能-可以处理附录A中操作任务的任选组合性能-有能力支持100个以上的并发用户</font>

   ​			<font color='orange'>性能-平均响应时间应小于1秒，最大响应时间应小于5秒。</font>

2. 必须在对话窗口的中间显示错误警告，其中使用红色的、14点加粗Arial字体。

   <font color='orange'>其中：功能-能显示错误警告</font>

   ​			<font color='orange'>设计约束-在对话窗口的中间显示,并使用红色的、14点加粗Arial字休。</font>



#### **功能的基本性质**

IEEE标准830-1998要求单一需求必须具有5个基本性质：

1. 必要的(Necessary)。是要求的吗?
2. 无歧义的(Unambiguous)。只能用一种方式解释吗?
3. 可测的(testable)。可以对它进行测试吗?
4. 可跟踪的(Traceable)。可以从一个开发阶段到另一个阶段对它进行跟踪吗?
5. 可测量的(Measurable)。可以对它进行测量吗?

<font color='orange'>注:确定一个需求是否满足以上五个性质是复杂耗时的过程.</font>



### **需求的分类**

功能；性能；外部接口；设计约束、质量属性



#### **功能属性**

功能需求规约了系统或系统构件必须执行的功能。

例如：

- 系统应对所有已销售的应纳税商品计算销售税
- 系统应提供一种方法，使系统用户可根据本地利率调整销售税比例
- 系统应能够产生月销售报表

除了对要执行的功能给出一个陈述外，还应规约如下内容：

1. 关于该功能输入的所有假定，或为了验证该功能输入，有关检测的假定。
2. 功能内的任一次序，这一次序是与外部有关的。
3. 对异常条件的响应，包括所有内外部所产生的错误。
4. 需求的时序或优先程度。
5. 功能之间的互斥规则。
6. 系统内部状态的假定。
7. 为了该功能的执行，所需要的输入和输出次序。
8. 用于转换或内部计算所需要的公式。

<font color='red'>注：功能需求是整个需求的主体，即没有功能需求，就没有非功能需求，即性能需求、外部接口需求、设计约束和质量属性。</font>



#### **性能需求**

性能需求(Performance requirement)规约了一个系统或系统构件必须具有的性能特性。

例如：

- 系统应该在5分钟内计算出给定季度的总销售税。

- 系统应该在1分钟内从100000条记录中检索出一个销售定单。

- 该应用必须支持100个Windows 95/NT工作站的并行访问。

  注:性能需求隐含了一些满足功能需求的设计方案，经常对设计产生一些关键的影响。例如:排序，关于花费时间的规约将确定哪种算法是可行的。



#### **外部接口需求**

外部接需求(External interface requirement)规约了系统或系统构件必须与之交互的硬件、软件或数据库元素。它也可能规约其格式、时间或其他因素。

例如：

- 账户接收系统必须为月财务状况系统提供更新信息，如在“财务系统描述”第4修订版中所描述的。
- 引擎控制系统必须正确处理从飞行控制系统接收来的命令，符合接控制文档B2-10A4，修订版C的1到8段的规定。

外部接口分为以下几类：

- 系统接口(System interfaces):描述一个应用如何与系统的其他应用进行交互。
- 用户接口(User interfaces):规约了软件产品和用户之间接口的逻辑特性。即规约对给用户所显示的数据，对用户所要求的数据以及用户如何控制该用户接。
- 硬件接口(Hardware interfaces):如果软件系统必须与硬件设备进行交互，那么就应说明所要求的支持和协议类型。
- 软件接口(Software interfaces):允许与其它软件产品进行交互，如，数据管理系统、操作系统或数学软件包。
- 通讯接口(Communications interfaces):规约待开发系统与通讯设施（如，局域网）之间的交互。如果通讯需求包含了系统必须使用的网络类型(TCP/IP，WindowsNT，Novell)，那么有关类型的信息就应包含在SRS中。
- 内存约束(Memory constraints):描述易失性存储和永久性存储的特性和限制，特别应描述它们是否被用于与一个系统中其它处理的通讯。
- 操作(Operation):规约用户如何使系统进入正常和异常的运行以及在系统正常和异常运行下如何与系统进行交互。应该描述在用户组织中的操作模式，包括交互模式和非交互模式;描述每一模式的数据处理支持功能;描述有关系统备份、恢复和升级功能方面的需求。
- 地点需求(Site adaptation requirements):描述系统安装以及如何调整一个地点，以适应新的系统。



#### **设计约束需求**

设计约束限制了系统或系统构件的设计方案。就约束的本身而言，对其进行权衡或调整是相当困难的，甚至是不可能的。它们必须予以满足。这一性质，是与其它需求的最主要差别。为了满足功能、性能和其它需求，许多设计约束将对软件项目规划、所需要的附加成本和工作产生直接影响。

例如：

- 系统必须用C++或其他面向对象语言编写。系统用户接口需要菜单。
- 任取10秒，一个特定应用所消耗的可用计算能力平均不超过50%。
- 必须在对话窗口的中间显示错误警告，其中使用红色的、14点加粗Arial字体。



#### **质量属性需求**

质量属性(Quality attribute)规约了软件产品必须具有的一个性质是否达到质量方面一个所期望的水平。

例如：

| 属性       | 描述                                                         |
| ---------- | ------------------------------------------------------------ |
| 可靠性     | 软件系统在指定环境中没有失败而正常运行的概率。               |
| 存活性     | 当系统的某一部分系统不能运行时，该软件继续运行或支持关键功能的可能性。 |
| 可维护性   | 发现和改正一个软件故障或对特定的范围进行修改所要求的平均工作。 |
| 用户友好性 | 学习和使用一个软件系统的容易程度。                           |
| 安全性     | 在一个预定的时间内，使软件系统安全的可能性。                 |
| 可移植性   | 软件系统运行的平台类型。                                     |



### **需求发现**

#### **自悟**

需求人员把自己当作系统最终用户，审视该系统并提出问题。

适用条件：需求工程师不能直接与客服交流

成功条件：需求人员必须具有比最终用户还要多的应用领域和过程方面的知识，具有良好的想象能力。



#### **交谈**

需求人员提出问题，用户回答，直接询问用户想要的是一个什么样的系统

成功条件：

- 需求人员是否具备“正确提问”的能力
- 回答人员是否具有“揭示需求本意”的能力

存在的风险：交谈期间需求可能不断增长，提出不合理的需求导致项目成本和进度的限制

应对措施：项目管理人员和客户管理人员应该定期对交谈过程进行评审



#### **观察**

观察用户执行其现行任务和过程，通过观察他们如何操作所期望的新系统或现有相关系统

存在的风险：

- 客户可能抵触这一观察。认为开发者打扰他们的正常业务
- 客服可能认为开发者在签约前就已经熟悉他们的业务



#### **小组会**

举行客户和开发人员的会议

通常哟开发组织的首席需求工程师或者软件工程项目经理，主持这一会议

依赖于其应用领域和主持人的能力。主持人的作用主要是掌握会议的进程

必须仔细选择小组成员，不仅考虑他们对现存和未来运行环境的理解程度，还要考虑他们的人品



#### **提炼**

复审现有文档，并提炼处相关信息

适用条件：提炼方法是针对已经有了的需求文档的情况。根据产品本来的情况可能很多文档需要复审，以确定其中是否包含相关联的信息



在实际生产过程中需要对以上几个方法进行综合的运用



### **需求规约（SRS）的概念和格式**

#### **概念**

一个需求规约是一个软件项目/产品/系统所有需求陈述的正式文档，是一个软件产品/系统的概念模型



#### **基本性质**

- 重要性和稳定性程度    例如：基本需求、可选需求和期望的需求
- 可修改：在不过多的影响其他需求的前提下，可以容易的修改一个单一的需求
- 完整的：没有遗漏的的需求
- 一致的：不存在互斥的需求

其中，就功能的需求规约来所，还应该考虑以下问题：

1. 功能源
2. 功能共享的数据
3. 功能与外部界面的交互
4. 功能所适用的计算资源



#### **格式**

```
1.引言
	1.1 目的
	1.2 范围
	1.3 定义，缩略语
	1.4 参考文献
	1.5 概述（既项目范围）
2.总体描述
	2.1 产品概述 
	2.2 产品功能
	2.3 用户特性
	2.4 约束
	2.5 假设和依赖
3.特定需求
附录
索引
```



## **结构化分析方法**

###  **结构化分分析模型**

#### 基本术语

1. 数据流、数据存储--支持数据抽象，加工--支持过程/功能的抽象，用于表达系统内涵
2. 数据源、数据潭--支持系统边界抽象，用于表达系统外延。
3. 是完备的。



#### **DFD图**

表达系统功能模型的工具

是一种描述数据变换的图形工具，包含的数据元素可以是数据流、数据存储、数据加工、数据源、数据潭等。

![image-20220423110100149](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20220423110100149.png)



#### **数据字典**

定义数据流和数据存储的结构，并给出构成所给出的数据流和数据存储的各项数据的基本数据类型。

<img src="https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20220423110234748.png" alt="image-20220423110234748" style="zoom:80%;" />

例如：

1. 数据流：

   销售的商品=商品名+商品编号+单价+数量+销售时间现金额=余额=日销售额=非负实数

   查询要求=[商品编号|日期]

   查询要求1=商品编号

   查询要求2=日期

   销售情况=商品名+商品编号+金额

2. 数据存储：

   销售文件={销售的商品}

3. 数据项（数据流及数据存储的组成部分）

   金额=非负实数

   ...



#### **加工小说明**

加工逻辑，包括其他一些与加工有关的信息，如执行条件、优先级、执行频率、出错处理等。

1. 结构化自然语言

   适用于加工的输入数据和输出数据之间的逻辑关系比较简单的加工描述

   ```
   if 20<订单量
   then 订票折扣为10%
   else 订票折扣为5%
   ```

2. 加工表

   适用于加工的输入数据和输出数据之间的逻辑关系比较复杂的加工描述

   ![image-20220423110923311](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20220423110923311.png)

   ![image-20220423111013324](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20220423111013324.png)

3. 判定树

   适用于加工的输入数据和输出数据之间的逻辑关系比较复杂的加工描述

   ![image-20220423111355275](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20220423111355275.png)



### **结构化分析过程**

#### **过程指导**

1. 建立系统的功能模型，使用工具为数据流图DFD

   1. 建立系统环境图（顶层数据流图），确定系统边界
   2. 自顶向下，逐步求精，建立系统的层次数据流图

2. 建立数据字典

   使用的工具为结构符：+、|、{}等

   定义数据流、数据存储、数据项

3. 给出加工小说明：集中描述加工逻辑，包括与加工有关的信息如：执行条件、优先级、执行频率、出错处理等，使用的工具可以是判定树、判定表等



实例：

```
建立一个简化的商业自动化系统，其中：
	营业员通过该系统记录每日销售的商品（商品名，商品编号，单价，数量，销售时间）
	收款员通过该系统记录收到的现金数额以及购物余额；
	商店经理每日统计销售额，并在必要时查看某种商品的销售情况（商品名，商品编码，金额）
```



#### 顶层数据流图

建立系统环境图，确定系统边界

![image-20220511205709194](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20220511205709194.png)

其中：

​	数据流为：销售的商品，日销售额等，3个输入流，3个输出流

​	数据源：营业员、收款员、经理

​	数据潭：收款员、经理



#### 自顶向下 逐步分解

1. 按人或部门的功能要求，将加工”打碎“，（将父图的每一加工按其功能分解为若干子加工）形成：

<img src="https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20220511212835295.png" alt="image-20220511212835295" style="zoom: 67%;" />

​		每一个加工需要给加工编号

2. 分派数据流（将父图的输入流和输出流分派到子加工），形成：

<img src="https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20220511213253961.png" alt="image-20220511213253961" style="zoom:67%;" />

​	其中：要根据特定的加工要求分派；保持与顶层数据流一致；

3. 引入文件，使之形成一个有机整体（在各加工之间建立合理的关系）

   <img src="https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20220511213645828.png" alt="image-20220511213645828" style="zoom:67%;" />

   注：到一个文件，既有输入流，又有输出流，可简化为<img src="https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20220511213830401.png" alt="image-20220511213830401" style="zoom:50%;" />，并可不给出标识。

继续上面的1、2、3：自顶向下，逐层分解。例如加工3可分解为：<img src="https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20220511214440415.png" alt="image-20220511214440415" style="zoom:67%;" />



#### 建立数据字典

定义数据流、数据存储、数据项

1. 数据流：

   销售的商品=商品名+商品编号+单价+数量+销售时间现金额=余额=日销售额=非负实数

   查询要求[商品编号|日期]

   查询要求1=商品编号

   查询要求2=日期

   销售情况=商品名+商品编号+金额

2. 数据存储

   销售文件={销售的商品}

3. 数据项（数据流及数据存储的组成成分）给出所有数据项的数据结果类型定义



#### 给出加工小说明

描述一个加工，一般遵循如下模版:

- 加工编号:给出加工编号
- 加工名:给出该加工的标识
- 输入流:给出该加工的所有输入数据
- 流输出流:给出该加工的所有输出数据流
- 加工逻辑:采用结构化自然语言或判定表或判定树等工具，给出该加工输入数据和输出数据之间的关系





## **结构化设计**

### **结构化设计的概念**

#### **设计的定义**

一种软件开发活动,定义实现需求规约所需的软件结构。

设计目标：依据需求规约，在一个抽象层上建立系统软件模型，包括软件体系结构（数据和程序结构），以及详细的处理算法，产生设计规格说明书。

即给出软件解决方案

结构化设计可分为：

- 总体设计：确定系统的整体模块结构，即系统实现所需要的软件模块以及这些模块之间的调用关系。
- 详细设计：详细描述模块



#### **整体框架**

![image-20220513213827507](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20220513213827507.png)



#### **对设计方法的需求**

实现软件设计的目标对结构化设计方法的需求

1. 提供可体现“原理/原则”的一组术语(符号)，形成一个特定的抽象层，用干表达设计中所使用的部件。
2. 依据术语所形成的“空间”，给出表达软件模型工具。
3. 给出设计的过程指导



#### **总体设计层概述**

1. 在总体设计层

   1. 引入了两个术语/符号

      - 模块：一种可独立标识的软件成分。<img src="https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20220513214334483.png" alt="image-20220513214334483" style="zoom:50%;" />
      - 调用：模块间的一种关系，模块a为了完成其任务必须依赖其他模块。<img src="https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20220513214350667.png" alt="image-20220513214350667" style="zoom:50%;" />

   2. 映入了模块结构图（MSD）

      用于表达软件系统的静态结构。

      ![image-20220513214917691](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20220513214917691.png)

   3. 过程指导

      为了实现设计目标，总体设计的具体任务是：将DFD转化为MSD

      分两部实现

      1. 如何将DFD转化为初始的MSD

         分类：变换型数据流图

         ​			事务型数据流图

         ​					变换设计

         ​					事务设计

      2. 如何将初始的MSD转化为最终可供详细设计使用的MSD

总体设计分为三个阶段：

第一阶段：初始设计。在对给定的数据流图进行复审和精化的基础上，将其转化为初始的模块结构图。**根据穿越系统边界的数据流初步确定系统与外部的接口**。

第二阶段：精化设计。依据模块“高内聚低耦合”的原则,精化初始的模块结构图，**并设计其中的全局数据结构和每一模块的接口**。

第三阶段：设计复审阶段,对前两个阶段得到的高层软件结构进行复审，必要时还可能需要对软件结构做一些精化工作。



### **初始模块结构图的设计**

#### **数据流图的分类**

- 变换型数据流图

  具有较明显的输入部分和变换部分之间的界面、变换部分和输出部分之间界面的数据流图。

  <img src="https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20220513215852668.png" alt="image-20220513215852668" style="zoom:80%;" />

  <img src="https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20220513215935190.png" alt="image-20220513215935190" style="zoom:80%;" />

  逻辑输入：e
  逻辑输出：g,h
  物理输入：a,b
  物理输出：z,y

  逻辑输入：离物理输入最远、仍被看成系统输入的数据流

  逻辑输出：离物理输出最远、仍被看成系统输出的数据流

- 事务型数据流图

  数据到达一个加工（例如下图），该加工根据输入数据的值，在其后的若干动作序列（称为一个事务）中选出一个来执行，这类数据流图称为事务型数据流图。![image-20220513220324628](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20220513220324628.png)

  事务型DFD完成下述任务

  1. 接受输入数据
  2. 分析并确定对应的事务
  3. 选取与该事务对应的一条活动路径

  事务DFD和变换型DFD的区别

  - 原则上所有DFD都可以看成是变换型DFD
  - 一般而言，接受一个输入数据，分成多条路径



#### **变化设计的基本步骤**

1. 设计准备-复审并精化系统模型

   - 为了确保系统的输入数据和输出数据符合实际情况而复审其语境
   - 为了确保是否需要进一步精化系统的DFD图而复审其语境

2. 确定输入、变换、输出这三部分之间的边界

   - 根据加工的语义和相关的数据流，确定系统的逻辑输入和逻辑输出

     <img src="https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20220513221054774.png" alt="image-20220513221054774" style="zoom:67%;" />

3. 第一级分解-系统模块结构图顶层和第一层的设计

   - 主模块：位于最顶层，一般以所建系统的名字命名，其任务是协调控制第一层模块
   - 输入模块部分：为主模块提供加工数据，有几个逻辑输入就设计几个输入模块
   - 变换模块部分：接受输入模块部分的数据，并对内部形式的数据加工，产生系统所有的内部输出数据
   - 输出模块部分：将变换模块产生的输出数据，以用户可见的形式输出。有几个逻辑输出，就设计几个输出模块

4. 第二级分解—自顶向下，逐步求精

   - 对每一个输入模块设计其下层模块
     - 接收数据模块（即输入模块)
     - 把接收的数据变换成它的上级模块所需的数据（即变换模块)
     - 直到输入模块为物理输入，则细化停止
   - 对每一个输出模块设计其下层模块
     - 将得到的数据向输出形式进行转换
     - 将转换后的数据进行输出
     - 直到输出模块是物理输出，则细化停止
   - 对变化模块进行分解（无通用法则)

![image-20220514214948411](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20220514214948411.png)



#### **事务设计的基本步骤**

1. 设计准备—复审并精化系统模型

   - 为了确保系统的输入数据和输出数据符合实际情况而复审其语境
   - 为了确保是否需要进一步精化系统的DFD图而复审其语境

2. 确定事务处理中心

3. 第一级分解—系统模块结构图顶层和第一层的设计

   - 首先，为事务中心设计一个主模块
   - 然后，为每一条活动路径设计一个事务处理模块
   - 对其输入部分设计一个输入模块
   - 如果一个事务数据流图的活动路径集中于一个加工，则设计一个输出模块，否则第一层不设计输出模块

   第一级分解举例

   <img src="https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20220514215535818.png" alt="image-20220514215535818" style="zoom:50%;" />

4. 第二级分解—自顶向下，逐步求精

   - 对于输入模块、输出模块的细化，如同变化设计的细化过程
   - 对各条路径模块的细化，无设计法则

   <img src="https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20220514215741157.png" alt="image-20220514215741157" style="zoom:50%;" />



DFD->初始的MSD

- 一个系统的DFD，通常是变换型数据流图和事务型数据流图的组合
- 自动的变换设计
- 自动的事务设计

<img src="https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20220514215917171.png" alt="image-20220514215917171" style="zoom:67%;" />



### **初始模块结构图精细化的原则**

#### **精化的概念**

模块，模块化。基于模块化原理—**高内聚，低耦合**。给出设计原则—经验规则-启发式规则。用于精化初始的MSD-体现设计人员的创造。



#### **模块**

执行一个特殊任务的一组例程和数据结构

- 接口：给出可由其他模块和例程访问的对象
  - 常量、变量、数据类型、函数
- 实现：接口的实现（模块功能的执行机制）
  - 私有量、过程代码、源程序代码
- 模块化：把系统分解成若干模块的过程



#### **为什么要模块化**

- 设C(x)是定义问题x复杂性的函数，E(x)是定义解决问题x所需要的工作量，那么，对于两个问题p1和p2，如果

  ​	C(p1)>C(p2)

- 那么

  ​	E(p1)>E(p2)

- 人们又发现另外一个有趣的特征：

  ​	C(p1+p2)>C(p1)+C(p2)

- 由以上结论：

  ​	IF C(g1)>C(g2) Then E(g1)>E(g2)

- 所以

  ​	E(p1+p2)>E(p1)+E(p2)

一个理想的情况

​	如果我们能够无限制地划分软件，那么开发它所需的工作量可以变得非常小，乃至可以忽略!

但是，这个结论是错误的

​	随着模块数量的增长，集成模块所需的工作量（成本)也在增长。

<img src="https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20220514222542984.png" alt="image-20220514222542984" style="zoom:67%;" />

#### **基本原则**

**高内聚，低耦合**



#### **耦合**

不通模块之间相互依赖程度的度量

耦合的强度所依赖的因素：

- 一个模块对另一个模块的引用
- 一个模块向另一个模块传递的数据量
- 一个模块施加到另一个模块的控制的数量
- 模块之间接的复杂程度



耦合类型：（由强到弱）

- 内容耦合：一个模块直接修改或操作另一个模块的数据。

- 公共耦合：两个以上的模块共同引用一个全局数据项。
- 控制耦合：一个模块向另一模块传递一个控制信号，接受信号的模块将依据该信号值进行必要的活动。
- 标记耦合：两个模块至少有一个通过界面传递的公共参数,包含内部结构，如数组，字符串等。
- 数据耦合：模块间通过参数传递基本类型的数据。

<img src="https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20220514223111908.png" alt="image-20220514223111908" style="zoom:50%;" />

原则：**如果模块间必须存在耦合,就尽量使用数据耦合,少用控制耦合,限制公共耦合的范围,坚决避免使用内容耦合。**



#### **内聚**

一个模块之内各成分之间相互依赖度的度量

好的设计满足：

- 模块功能单一
- 模块的各部分都和模块的功能直接相关
- 高内聚

内聚类型（由低到高）：

- 偶然内聚：一个模块之内各成分之间没有任何关系
- 逻辑内聚：几个逻辑上相关的功能放在同一模块中
- 时间内聚：一个模块完成的功能必须在同一时间内完成，而这些功能只是因为时间因素关联在一起
- 过程内聚：处理成分必须以特定的次序执行。
- 通信内聚：各成分都操作在同一数据集或生成同一数据集。
- 顺序内聚：各成分与一个功能相关，且一个成分的输出作为另一成分的输入
- 功能内聚：模块的所有成分对完成单一功能是最基本的，且该模块对完成这一功能而言是充分必要的

<img src="https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20220514223644868.png" alt="image-20220514223644868" style="zoom:67%;" />

<img src="https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20220514223707280.png" alt="image-20220514223707280" style="zoom:67%;" />



## **结构化设计方法2**

### **初始化模块结构图精华的启发式规则**

#### **常见的启发式规则**

什么叫做“启发式”？

- 更具设计准则，从长期的软件开发实践中，总结出来的规则。
- 既不是设计目标，也不是设计时应该普遍遵循的原理

常见的六种启发式规则：

- 改进软件结构，提高模块独立性

  - 通过模块的分解和合并，力求降低耦合提高内聚	

    例：多个模块公用的子功能可以形成一个模块，供这些模块调用

- 模块规模适中，每页60行语句

  - 心理学研究表明：模块语句>30之后，可理解性迅速下降
  - 方法：进一步分解过大的模块，将频繁调用的小模块合并到上级模块中

- 深度、宽度、扇入、扇出适中

  - 深度：软件结构中的控制的层数

    ​	标示一个系统的大小和复杂程度

  - 宽度：软件结构中，同一层次上的模块总数最大值

    ​	宽度越大系统越复杂

  - 扇入：表示有多少个上级模块直接调用它

    ​	一般而言，扇入越大表示共享它该模块上级模块越多

    ​	不违背模块独立性的条件下，扇入越大越好

  - 扇出：一个模块直接控制（调用）的下级模块数目

    ​	扇出过大意味着模块过分复杂

    ​	扇出过小意味着功能过分集中

    ​	典型的3或者4（上限5-9）

    ​	好的系统：顶层扇出高，中层扇出少，底层扇入高，呈葫芦型

    <img src="https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20220515111513995.png" alt="image-20220515111513995" style="zoom:50%;" />

- 模块的作用域力争在控制域之内

  - 作用域：该模块内一个判定影响所有模块的集合
  - 控制域：模块本身+直接或间接从属于它的模块集合

- 降低模块接口的复杂性

  - 使得信息传递简单，并且和模块的功能一致
  - 接口复杂或不一致往往导致紧耦合和低内聚

- 模块功能应该可以预测

  - 什么叫做“功能可以预测”？

    <img src="https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20220515111920201.png" alt="image-20220515111920201" style="zoom:67%;" />

  - 什么样的模块功能不可预测？

    模块带有内部状，输出取决于该状态



#### **输入部分的精化**

<img src="https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20220515112356282.png" alt="image-20220515112356282" style="zoom: 80%;" />

<img src="https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20220515112418011.png" alt="image-20220515112418011" style="zoom: 80%;" />



#### **输出部分的精化**

<img src="https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20220515112546733.png" alt="image-20220515112546733" style="zoom:80%;" />

<img src="https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20220515112627032.png" alt="image-20220515112627032" style="zoom:80%;" />



#### **变换部分的精化**

对于变换部分的求精，是一项具有挑战性的工作。其中主要是根据设计准则，并要通过实践,不断地总结经验，才能设计出合理的模块结构。

<img src="https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20220515112850219.png" alt="image-20220515112850219" style="zoom:80%;" />



### **接口设计**

#### **接口设计的分类**

接口设计主要包括3个方面

1. 模块或软件构件间的接口设计
2. 软件与其他软硬件系统之间的接口设计
3. 软件与人（用户）之间的交互设计

系统的接口设计(包括用户界面设计及与其他系统的接口设计）是由穿过系统边界的数据流定义的。

在最终的系统中,数据流将成为用户界面中的表单、报表或与其他系统进行交互的文件或通信。



#### **人机交互界面**

在设计阶段，必须根据需求把交互细节加入到用户界面设计中，包括人机交互所必须的实际显示和输入。

人机交互界面是给用户使用的，为了设计好人机交互界面，设计者需要了解以下信息：

1. 用户界面应具有的特性?
2. 使用软件的用户是什么人?
3. 用户怎样学习与新的计算机系统进行交互?
4. 用户需要完成哪些工作?



#### **用户界面应具备的特性**

- 可使用性：是用户界面设计最重要的目标。包括使用简单、界面一致、拥有help帮助功能、快速的系统响应和低的系统成本、具有容错能力等。
- 灵活性：考虑到用户的特点、能力和知识水平，应该使用户接满足不同用户的要求。因此，对不同的用户，应有不同的界面形式，但不同的界面形式不应影响任务的完成。
- 可靠性：用户界面的可靠性是指无故障使用的间隔时间。用户界面应能保证用户正确、可靠地使用系统，保证有关程序和数据的安全性。



#### **界面设计类型**

##### 用户类型

- 外行型：对计算机系统认知很少或毫无了解
- 初学型：对计算机有一定经验，对系统的认识不足或经验很少，**需要很多界面支持**。
- 熟练型:对一个系统有很多经验，需要较少的界面支持，但不能处理意外错误。
- 专家型：了解系统的内部构造，需要为他们提供能够修改和扩充系统能力的复杂界面。



##### **界面设计类型**

如果从用户与计算机交互的角度来看，用户界面设计类型主要有问题描述语言、数据表格、图形、菜单、对话、窗等。在选用界面形式的时候，应该考虑每种类型的优点和限制可以从以下几个方面来考察，进行选择：

- 使用的难易程度
- 学习的难易程度
- 操作速度
- 复杂程度：该界面提供了什么功能、能否用新的方式组合这些功能以增强界面的功能
- 控制：人机交互时，由计算机还是由人发起和控制对话。
- 开发的难易程度：该界面设计是否有难度、开发工作量有多大。

一个界面的设计通常使用一组以上的设计类型，每组类型与一个或一组任务相匹配。



#### **设计原则**

遵循的原则：

- 一致性
- 操作步骤少
- 不要“哑播放”
- 提供Undo功能
- 减少人脑的记忆负担
- 提高学习效率



### **数据设计**

在设计阶段必须对要存储的数据及其格式进行设计。

#### **文件设计**

以下几种情况适合于选择文件存储：

- 数据量较大的非结构化数据，如多媒体信息;
- 数据量大，信息松散，如历史记录、档案文件等;
- 非关系层次化数据。如系统配置文件
- 对数据的存取速度要求极高的情况

文件设计的主要工作就是根据使用要求、处理方式、存储的信息量、数据的活动性以及所提供的设备条件等确定文件类型，选择文件媒体，决定文件组织方法，设计文件记录格式，并估算文件的容量。



#### **数据库设计**

在结构化设计中，很容易将结构化分析阶段建立的数据字典和实体-关系模型映射到关系数据库中。

- 数据对象的映射

- 关系的映射



## **结构化设计方法3**

### **详细设计工具**

#### **详细设计概览**

任务：定义每一模块

主要引入了关于三种动作控制结构的术语/符号

三种控制结构：顺序、选择、循环



#### **伪码**

顺序：begin s1;s2;...sn end;

选择：if 条件表达式 then s1
									else s2;

循环：while 条件表达式 do s；

伪码是一种混合语言。外部采用形式定义语言控制结构和数据结构，内部使用自然语言。

例如：

```
Begin
	输入一元二次方程
		a,b,c;
	if b^2-4ac >= 0 then计算实根
	else 输出无实根
end
```

优点：PDL不仅可以作为设计工具，而且可作为注释工具，直接插在源程序中间，以保持文档和程序的一致性，提高了文档的质量.

缺点：

1. 不如图形工具那样形象直观
2. 当描述复杂的条件组合与动作间的对应关系时，不如判定表和判定树那样清晰简单



#### **程序流程图**

![image-20220515163756863](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20220515163756863.png)

<img src="https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20220515163814034.png" alt="image-20220515163814034" style="zoom:67%;" />

优点：对控制流程的描绘很直观,便于初学者掌握

缺点：

1. 不是一种逐步求精的工具，程序员过早地考虑程序的控制流程，而不是全局结构
2. 所表达的控制流,可以不受约束随意转移
3. 不易表示数据结构



#### **PAD图**

![image-20220515164014940](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20220515164014940.png)

优点：

1. 支持自顶向下逐步求精的结构化详细设计，可使用“def”符号逐步增加细节
2. PAD图最左边的竖线是程序的主线，随着程序层次的增加，逐步向右延伸，每增加一个层次，图形向右扩展一条竖线，从而使PAD图所表现的处理逻辑易读、易懂和易记。



#### **N-S图**

![image-20220515164141160](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20220515164141160.png)

优点：支持自顶向下逐步求精的结构化详细设计，并且严格限制了控制从一个处理到另一个处理的转移



#### **判定表和判定树**

当算法中包含多重嵌套的条件选择时，用程序流程图、盒图、PAD图、PDL都不易清楚描述，这时可以选择判断表来表达复杂的条件组合与应做的动作之间的对应关系

判定树是判定表的变种，也能清晰地表达复杂的条件组合与应做的动作之间的对应关系，形式简单，但简洁性不如判定表，数据元素的同一个值往往需要重复写多次，而且越接近树的叶断重复次数越多



### **软件设计规约**

#### **概念和组成**

什么是软件设计规约？

**软件设计规约**对软件的组织或其组成部分的内部结构的描述，满足系统需求规约所指定的全部功能及性能要求。

软件设计规约的组成

软件设计规约通常有**概要设计规约**和详细设计规约,分别为相应设计过程的输出文档。



#### **概要设计规约**

指明软件的组织结构，其主要内容包括：

1. 系统环境
   - 硬件、软件接口与人机界面
   - 外部定义的数据库
   - 与设计有关的限定条件
2. 设计描述
   - 数据流和主要数据结构
   - 软件模块的结构
   - 模块之间的接口
3. 对每个模块的描述
   - 处理过程外部行为
   - 界面定义
   - 数据结构
   - 必要的注释
4. 文件结构和全局数据
   - 文件的逻辑结构、记录描述以及访问方式
   - 交叉引用信息

此外，还应包括有关软件测试方面的要求和说明。

软件概要设计是面向软件开发者的文档，主要作为软件项目管理人员、系统分析人员与设计人员之间交流的媒体。



#### **详细设计规约**

详细设计规约是对软件各组成部分内部属性的描述，它是概要设计的细化。即在概要设计规约的基础上，增加以下内容：

1. 各处理过程的算法
2. 算法所涉及的全部数据结构的描述，特别地，对主要数据结构往往包括与算法实现有关的描述

软件设计规约主要作为软件设计人员与程序员之间交流的媒体。



#### **设计规约格式**

![image-20220515170720406](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20220515170720406.png)

![image-20220515170747300](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20220515170747300.png)

![image-20220515170814122](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20220515170814122.png)

![image-20220515170841771](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20220515170841771.png)

![image-20220515170919520](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20220515170919520.png)

![image-20220515170953952](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20220515170953952.png)

![image-20220515171015858](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20220515171015858.png)

![image-20220515171142069](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20220515171142069.png)



### **软件设计评审**

#### **概念**

设计评审(Design Review)，就是对设计文档的评审。对于软件设计来说，评审与其技术设计方法本身是一样重要，评审对于研制项目的成功而言是绝对必要的。对设计进行评审是为了尽早发现软件的欠缺，尽可能把这些缺欠在进入下一阶段工作之前，予以纠正，从而避免后期付出更多的代价。



#### **指南**

目前存在着两种不同的设计评审方法：非正式评审、正式技术评审

软件设计评审的指南

- 概要设计评审和详细设计评审应该分开进行，不允许合并为一次复审
  - 概要设计评审评价从需求到设计数据和体系结构的变换
  - 详细设计评审，通常叫详细设计走查(walkthrough) ,注重算法过程的正确性
- 建立一个议事日程并遵循它
- 评审设计文档，不评审设计者
- 评审中提出的问题应详细记录，但不要谋求当场解决
- 限制参与人数和坚持充分准备
  - 除软件开发人员外，概要设计评审必须有用户代表参加，必要时还可邀请有关领域的专家到会
  - 详细设计评审一般不邀请用户和其他领域的代表
- 为设计文档开发一个检查表，以帮助评审人员集中在重要问题上
- 为了提高评审的效率，所有评审的参加者应接受一定的正规的培训
- 评审结束前，应作出本次评审能否通过的结论



#### **评审检测表**

概要设计评审检查表如下：

- 软件体系结构是否反映了软件需求?
- 达到高的模块化吗?
- 模块功能独立吗?
- 模块与外部系统元素接口定义了吗?
- 数据结构与软件需求一致吗?
- 考虑了可维护性吗?
- 是否直接评价了质量因素?

详细设计评审检查表如下：

- 算法能完成所要求的功能吗?
- 算法逻辑正确吗?
- 接口与体系结构设计一致吗?
- 逻辑的复杂性合理吗?
- 是否规定了错误处理和反故障处理?
- 正确地定义了局部数据结构吗?
- 都使用了结构化变成构造吗?
- 设计的细节适用于实现语言吗?
- 用的是哪个操作系统或语言独立性质?
- 考虑到可维护性吗?



## **UML-1**

### **面向对象的概念**

面向对象方法是一种以对象、对象关系等来构造软件系统模型的系统化方法。

面向对象方法的世界观:一切系统都是由对象构成的，它们的相互作用、相互影响，构成了大千世界的各式各样系统。



#### **什么是面向对象**

- 面向对象不仅仅是一种程序开发方法
  - 使用面向对象程序设计语言
  - 使用对象、类、继承、封装、消息等基本概念进行编程
- 面向对象是一种软件方法学
  - 如何看待软件系统与现实世界的关系
  - 以什么观点进行求解
  - 如何进行系统构造



#### **面向对象方法的主要特点**

1. 从问题域中客观存在的事物出发来构造软件系统：
   1. 用对象（系统中用来描述客观事物的一个实体）为对这些事务的抽象表示，并以此作为系统的基本构成单位
   2. 事物的静态特征用对象的属性表示
   3. 事物的动态特征（即事物的行为）用对象的操作表示
2. 对象的属性和操作结合为一体，构成一个独立的实体，对外屏蔽其内部细节（封装）
3. 对事物进行分类，把具有相同属性和相同操作的对象归为一类，类是这些对象的抽象描述，每个对象是它的类的一个实例。
4. 通过在不同程度上运用抽象的原则（较多或较少地忽略事物之间的差异)，可以得到较一般的类和较特殊的类。特殊类继承一般类的属性和操作，面向对象方法支持对这种继承关系的描述和实现，从而简化系统的构造过程及其文档
5. 复杂的对象可以用简单的对象作为其构成部分（聚合）
6. 对象之间只能通过消息进行通信（不允许一个对象直接使用另一个对象的属性），以实现对象之间的动态联系
7. 用关联类表达类之间的静态关系



#### **面向对象方法的基本思想**

- 从现实世界中客观存在的事物出发建立软件系统
  - 强调直接以问题域（现实世界）中的事物为中心来思考问题、认识问题，并根据这些事物的本质特征，把它们抽象地表示为系统中的对象，作为系统的基本构成单位。这可以使系统直接映射问题域，保持问题域中事物及其相互关系的本来面貌。
- 充分运用人类日常的思维方法
  - 强调运用人类在日常的逻辑思维中经常采用的思想方法与原则，例如抽象、分类、继承、聚合、封装、关联等等。这使得软件开发者能更有效地思考问题，并以其他人也能看得懂的方式把自己的认识表达出来。



### **UML的概念**

#### **UML概述**

UML是一种可视化语言，用于：

1. 规约系统的制品--UML适用于对所有重要的分析、设计和是实现决策进行详细描述
2. 构造系统的制品--UML描述的模型可与各种编程语言直接相关联



#### **面向对象方法术语/符号**

基于面向对象方法的世界观，即“大千世界是由对象组成的，对象有其自己的属性和运动规律，对象之间的相互作用构成了客观世界各种各样的系统。”为了支持软件开发，面向对象方法主要提供了两类术语：

一类是结构化地表达客观事物地术语

一类是表达客观事物之间关系（相互作用\相互影响）的术语

注：除了这两类术语之外，

1. 为了控制信息组织的复杂性，还引入了用于组织特定对象结构的包。包是模型元素的一个分组。一个包本身可以嵌套在其他包中，并且可以具有子包和其他种类的模型元素。
2. 为了使建造的系统模型容易理解，引入了术语-注解，用于对模型增加一些辅助性说明。



### **类与对象**

体现抽象数据

#### **定义与表示**

类（class）：是一组具有相同属性、操作、语义和关系的对象的描述

对象（object）：对象是类的一个实例

类表示为具有三个栏目的矩形，如下图所示：

![image-20220519212859756](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20220519212859756.png)

根据类出现的场景1，可以给出如下简化的表示：

![image-20220519213118353](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20220519213118353.png)

类可以是抽象类，既没有实例的类，此时类采用斜体字，例如：

![image-20220519213200717](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20220519213200717.png)



#### **类名**

类的标识

1. 类名使用黑体字，第一个字母通常要大写，并位于第一栏的中央
2. 类名往往是从正被建模系统的词汇表中提取的简单名词或名词短语



#### **属性**

属性是类的一个命名特性，有该类的所有对象共享，用于表达对象状态的数据

![image-20220519213521392](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20220519213521392.png)

1. 一个属性往往具有所属的类型，用于描述特性的实例可以取值的范围
2. 类的一个对象对每一个属性应有特定的值
3. 一个类可以有多个属性，也可以没有属性



属性的作用范围：

1. 实例范围的属性：一个类的所有对象具有相同的属性即属性的个数、名称、数据类型相同，但属性值可不同，并随程序的执行而变化。

2. 类范围的属性：描述类的所有对象共同特征的一个数据项，对于任何对象实例，它的属性值都是相同的，通常对属性加下划线来表示该属性是实例范围的属性.

   <img src="https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20220519213932023.png" alt="image-20220519213932023" style="zoom:67%;" />



定义属性的格式为：

[可见性]属性名[:类型] [多重性] [=初始值] [{特性串}]

1. 可见性：表面该属性是否能被其他类所使用。

   其可见性的值可以为：

   +公有的：可供其它类使用

   #受保护的：其子类可以使用

   私有的:只有本类的操作才能使用

   ~包内的:只有在同一包中声名的类才能使用

   也可以使用关键字public、protected、 private和package，分别表示公有的、受保护的、私有的和包内的。

2. 属性名：属性名是一个表示属性名字的标识串。通常以小写字母开头，左对齐。

3. 类型：类型是对属性实现类型的规约，与具体实现语言有关。

4. 多重性：多重性用于表达属性值的数目。即该类实例的这一特性可以具有的值的范围。

   例如：point[2..*]:Point

   多重性是可以省略的。在这种情况下，多重性是1..1。即属性只含一个值。如果多重性是0..1，就有可能出现空值。

5. 初始值：初始值是与语言相关的表达式，用于为新建立的对象赋予初始值。例如: origin:Point=(0,0)

   初始值是可选的。如果不声明对象这一属性的初始值，那么就要省略语法中的等号。对象的构造函数可以参数化或修改默认的初始值。

6. 性质串：如果说“类型”、“多重性”以及“初始值”都是围绕一个属性的可取值而给出的，那么“性质串”是为了表达该属性所具有的性质而给出的。例如:

   a:integer=1{frozen}

   其中，“frozen”是一个性质串，表示属性是不可以改变的。如果没有对一个属性给出这一性质串，那么就认为该属性是可以改变的。

属性的声明举例：

<img src="https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20220519214753646.png" alt="image-20220519214753646" style="zoom:67%;" />



#### **操作**

操作是对一个类中所有对象要做的事情的抽象。

![image-20220519214900941](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20220519214900941.png)

1. 一个类可以有多个操作，也可以没有操作

2. 操作名除第一个词之外，其他每个词的第一个字母要大写

3. 操作名往往是描述其所在类的行为的动词或动词短语

4. 可以通过给出操作的特征标记进一步描述之，特征标记通常包括参数名、类型和默认值;如果该操作是一个函数，那么其特征标记还包括返回类型。如下所示：

   ![image-20220519215339086](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20220519215339086.png)

5. 操作可以是抽象操作，即没有给出实现的操作。此时的操作名采用斜体。例如：

   ![image-20220519215405927](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20220519215405927.png)

6. 调用一个对象上的操作可能会改变该对象的数据或状态。



操作的作用范围：

![image-20220519215453680](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20220519215453680.png)



表达操作的完整语法格式为：

[可见性] 操作名 [(参数表)] [:返回类型] [{性质串}]

其中：

1. 可见性 如同属性的可见性一样，其值可以为：

   +共有的		 可供其他类访问

   #受保护的 	其子类能访问

   -私有的		  只有本类的操作才能访问

   ~包内的		 只有在同一包中声名的类才能访问

2. 操作名

   - 操作名一般是一动词或动词短语，通常以小写字母开头，左对齐
   - 如果操作名是动词短语，除第一个词外，其余每个词的第一个字母为大写，例如`isEmpty();`
   - 若操作是一个抽象操作，则以斜体字表示

3. 参数表

   给出该操作的参数。一个操作可以有参数表，也可以没有。如果有参数表的话，其语法为：

   [方向] 参数名: 类型 [=默认值]

   - 方向是对输入/输出的规约，其取值可以为：
     - in输入参数，不能修改
     -  inout输入参数，为了与调用者进行信息通讯，可能要对之进行修改
     - out输出参数，为了与调用者进行信息通讯，可能要对之进行修改.
   - 类型是实现类型的（与语言有关）规约
   - 默认值是一个值表达式，用最终的目标语言表示。该项是可选的

4. 返回类型

   返回类型是对操作的实现类型或操作的返回值类型的规约，它与具体的实现语言有关

   - 如果操作没有返回值（例如C++中的void)，就省略冒号和返回类型。
   - 当需要表示多个返回值时，可以使用表达式列表。
   - 根据实际问题的需要，可以省略全部的参数表和返回类型，但不能只省略其中的一部分。



#### **操作的多态性**

![image-20220519220404185](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20220519220404185.png)



## **UML-2**

### **表达客观事务的术语--接口及其他**

#### **接口**

体现功能抽象

##### **定义**

接口（interface）是一组操作集合，其中每每个操作描述了类或构件的一个服务。

##### **基本作用**

模型化系统中的“接缝”

即：

1. 通过一个接口，表明一个类、构件、子系统提供了所需要的、且与实现无关的行为
2. 表明一个类、构件、子系统、所要得到的、且与实现无关的行为

##### **接口的表示**

1. 可以用带有分栏和关键字\<\<interface>>的矩形符号来表示接口。其中:

   - 在操作分栏中给出接口支持的操作列表
   - 接口的属性分栏总是空的

   ![image-20220520221754675](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20220520221754675.png)

2. 可以用小圆圈来表示接口

   <img src="https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20220520222028919.png" alt="image-20220520222028919" style="zoom:67%;" />

   示例：<img src="https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20220520222355520.png" alt="image-20220520222355520" style="zoom:67%;" />



几点说明（仅以类为例）

- 接口只描述类(构件或子系统)的外部可见操作，并不描述内部结构。
- 通常，接口仅描述一个特定类的有限行为。接口没有实现,接口也没有属性、状态或者关联，接口只有操作。
  - 接口在形式上等价于一个没有属性、没有方法而只有抽象操作的抽象类。
- 接口只可以被其它类目使用，而其本身不能访问其它类目。
- 接口之间没有关联、泛化、实现和依赖，但可以参与泛化、实现和依赖关系。



#### **协作**

协作（collaboration）是一组类、接口和其他元素的群体，它们共同工作以提供比各组成部分的总和更强的合作行为。

协作是一个交互，涉及交互三要素：交互各方、交互方式以及交互内容。交互各方的共同工作提供了某种协作行为。

表示：

![image-20220520222721403](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20220520222721403.png)

两点说明：

1. 协作有两个方面：一个是结构部分，详细说明共同工作以完成该协作的类、接口和其他元素，经常用组合结构图或类图来表示；二是行为部分，详细说明这些元素如何交互；经常用交互图来表示。

   <img src="https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20220520222914855.png" alt="image-20220520222914855" style="zoom:67%;" />

2. 由于一个给定的类或对象可以参与多个协作，因此协作表现了系统细化的构成模式。

注意：**协作是系统体系结构的概念组块，不能拥有自己的结构元素，而仅引用或使用在其他地方声明的类、接口、构件、结点和其他结构元素。**



#### **用况**

用况（use case）是体现功能的抽象

是一组动作序列的描述，系统执行这些动作产生对特定的参与者一个有值的、可观察的结果。

表示：

![image-20220520223150145](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20220520223150145.png)

2点说明

1. 用况用于模型化系统中的行为，是建立系统功能模型的重要术语。一个用况描述了系统的一个完整的功能需求。
2. 用况是通过协作予以细化的。



#### **主动类**

主动类（active class）是体现并发行为抽象

是一种至少具有一个进程或线程的类，因此它能够启动控制活动。

表示：

![image-20220520223431861](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20220520223431861.png)

主要特征：主动类对象的行为通常与其他元素的行为是并发的。



#### **构件**

构件（component）描述比特世界的软件制品的系统单位

构件是系统中逻辑的并且可替换的成分，它遵循并提供了一组接口的实现。

表示：

![image-20220520223613488](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20220520223613488.png)

说明：

1. 在一个系统中，共享相同接口的构件可以相互替代，但其中要保持相同的逻辑行为。
2. 构件可以包含更小的构件。



#### **制品**

制品（artifact）是系统中物理的、可替代的部件，其中包含物理信息(比特)

表示：

![image-20220520223730876](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20220520223730876.png)

2点说明：

1. 在一个系统中，可能会存在不同类型的部署制品，例如源代码文件、可执行程序和脚本等。
2. 制品通常代表对源代码信息或运行时信息的一个物理打包



#### **节点**

节点（node）是在运行时存在的物理元素，通常它表示一种具有记忆能力和处理能力的计算机资源。

表示：

![image-20220520223909059](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20220520223909059.png)

说明：

- 一个构件可以驻留在一个节点中，也可以从一个节点移到另一个节点。



#### **结构化地表达客观事物的术语小结**

- 抽象客观世界中任何实体的基本术语

  UML给出了以上八个术语(模型化概念)

  类、接口、协作、用况、主动类、构件、制品、节点，它们是可包含在一个UML模型中的基本模型化元素。它们存在一些变体，例如：

  类的变体-参与者、信号、实用程序;

  主动类的变体-进程和线程;

  制品的变体-应用、文档、库、页和表等。

- 在UML中，把以上结构化概念统称为类目(classifier)



### **控制复杂性的术语--包**

为例组织类目，控制信息组织和文档组织的复杂性，UML引入了术语-包。

#### **语义**

包是模型元素的一个分组。一个包本身可以被嵌套在其他包中，并且可以含有子包和其他种类的模型元素。

一个包元素对外的可见性，可以通过在该元素名字前面加上可见性符号来表示：

+：对其他包而言是可见的

-：对其他包而言都是不可见的

#：对子包而言是可见的



#### **表示**

1. 通常，在大矩形中秒速包的内容，而把该包的名字放在左上角的小矩形中

   ![image-20220521112748527](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20220521112748527.png)

2. 可以把所包含的元素画在包外面，通过符号![image-20220521112914798](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20220521112914798.png)，将这些元素与该包相连。这时可把该包的名字放在大矩形中。

   ![image-20220521113011376](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20220521113011376.png)

   包拥有在其内所声明的模型元素，它们可以是类、接口、构件、协作、用况、节点，甚至可以是其他包。



#### **包之间的依赖关系**

两种依赖：访问依赖和引用依赖。作用：使一个包可以访问和引入其他包。

注：包间的依赖通常隐含了各包中元素之间存在着的一个或多个依赖。

1. 引入依赖

   从源包到目标包的引入依赖表明：目标包中有适当可见性的内容被加入到源包的公共命名空间中，这相当于源包对它们做了声明（即对它们的引用可不需要一个路径名）

   引入：《import》

   表示为从源包到目标包的一条带箭头的线段，并标记为《import》，如下图所示：

   <img src="https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20220521113717269.png" alt="image-20220521113717269" style="zoom: 80%;" />

   例如：

   <img src="https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20220521113839164.png" alt="image-20220521113839164" style="zoom:80%;" />

   注：包Policies引入包GUI，因此，对于类GUI::Window和类GUI::Form,包Policies的内容使用简单名Window和Form就能访问它们，然而，由于GUI::EventHandler是受保护的，因此它是不可见的。由于包Server没有引入包GUI,Server中的内容必须用限定名才能访问GUI的公共内容，如GUI::Window。由于Server的内容是私有的，GUI的内容无权访问Server中的任何内容，即使用限定名也不能访问它们。

2. 访问依赖《access》

   从源包到目标包的访问依赖表示：目标包中具有可见性的内容增加到源包的私有命名空间里(即源包可以不带限定名来引用目标包中的内容，但不可以输出之，即如果第三个包引入源包，就不能再输出已经被引入的目标包元素）。

   <img src="https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20220521114111646.png" alt="image-20220521114111646" style="zoom:80%;" />



#### **对成组的元素建模策略**

浏览特定体系结构视图中（如类图）的建模元素，找出概念或语义上相互接近的元素所定义的组块。

把每一个这样的组块围在一个包内。

对每一个包判别哪些元素要在包外访问，把这些元素标记为公共的，把所有其他元素标记为受保护的或私有的。

用引入依赖显示地连接建立在其他包之上的包。

在包的家族中，用泛化关系把特殊包连接到它们的较一般的包。



### **表达关系的术语**

在UML中，提供了以下4种关系，作为UML模型中的基本关系构造块，表达类目之间的关系，以构造一个结构良好的UML模型。

1. 关联（association）
2. 泛化（generalization） 
3. 实现（realization）
4. 依赖（dependency）



#### **关联**

定义：关联是类目之间的结构关系，描述了一组具有相同结构、相同语义的链（links）

链是对象之间的连接（connection）。例如：

![image-20220521123323663](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20220521123323663.png)

注：如一个关联只连接两个类目，称为二元关联

​		如一个关联连接n个类目，称为n元关联



关联的语义表达（6点）：

1. 关联名（name）：关联的标识，用于描述该关联的”涵义“。为了避免该关联涵义上的歧义性，可给出其关联方向

2. 角色名（role）：一个类参与一个关联的角色标识。在类的一个关联中，可以显示地命名角色，如下图所示：

   ![image-20220521123732122](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20220521123732122.png)

3. 多重性（multiplicity）：类中对象参与一个关联的数目，称为该关联角色的多重性，例如：

   ![image-20220521123826835](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20220521123826835.png)

   多重性的表达：

   ​	关联的一端多重性，说明：对于关联另一端的类的每个对象，本端的类可能有多少个对象出现。

   ​	![image-20220521124021495](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20220521124021495.png)

   上图多重性解释：每个公司对象可以雇佣一个或多个人员对象(多重性为1..\*)；每个人员对象受雇于0个或多个公司对象(多重性为\*,它等价于0..*)

4. 聚合（aggregation）：一种特殊形式的关联，表达一种”整体/部分“关系。即一个类表示了一个大的事物，它是由一些小的事物（部分）组成的。

   ![image-20220521124324143](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20220521124324143.png)

   

注意：不论是整体类还是部分类，它们在概念上是处于同一个层次的。

在建模实践中，这是区分是否把一类事物标识为一个部分类还是把它标识为一个类的属性的基本准则。

- 组合（composition）

  定义：如果整体类的实例和部分类的实例具有**相同的生命周期**这样的聚合称为组合。

  例如：人和人脑，人脑是人的部分，在主流医学实践中，人死亡的判定条件通常是脑死亡（相同的生命周期）。

  4点说明：

  - 组合是聚合的一种形式。部分和整体之间具有很强的“属于”关系，即具有一致的生存期；
  - 组合的末端，其多重性显然不能超过1；
  - 在一个组合中，由一个链所连接的对象而构成的任何元组，必须都属于同一个整体类的对象;
  - 在一个组合中，其部分可以包含一些类和关联；根据需要，也可以把它们规约为关联类。

  表示：

  <img src="https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20220521125015828.png" alt="image-20220521125015828" style="zoom:80%;" />

  上图给出了三种表示组合的方法：

  其中，类Window由类Slider（角色为scroller）、Header（角色为title）和Panel（角色为body）组成。

5. 限定符：

   一个限定符是一个关联的属性或属性表，这些属性的值将对该关联相关的对象集做了一个划分。

   ![image-20220521125355849](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20220521125355849.png)

   

   左图的限定符有一个属性account#，表明：在一个银行中，一个帐户对应一个用户，或没有对应人员。

   右图的限定符有两个属性，它们与Chessboard一起确定了Square，且Square是其组成部分。

6. 关联类

   一种模型元素，它有关联和类的特性。一个关联类，可以被看作是一个关联，但还有类的特性；或被看作是一个类，但有关联的特性。例如：

   ![image-20220521125532328](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20220521125532328.png)

   

#### **泛化**

定义：泛化是一般性事物（称为超类或父类）和它的较为特殊种类(称为子类）之间的一种关系，有时称为“is-a-kind-of”关系。

4点说明：

1. 子类可继承父类的属性和操作，并可有更多的属性和操作;

2. 子类可以替换父类的声明;

3. 若子类的一个操作的实现覆盖了父类同一个操作的实现，这种情况被成为多态性，但两个操作必须具有相同的名字和参数

4. 一个类可以有0个、1个或多个父类。没有父类且最少有一个子类的类被称为根类或基类；没有子类的类称为叶子类。如果一个类只有一个父类，则说它使用了单继承；如果一个类有多个父类，则说它使用了多继承。

   ![image-20220521131605262](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20220521131605262.png)

   注：在大多数情况中，用类和接口之间的泛化来表明继承关系。在UML中，也可在其他类目之间创建泛化，例如在结点之间。

表示：

![image-20220521131640618](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20220521131640618.png)

#### **实现**

也称细化。

定义：细化是类目之间的一种语义关系，其中一个类目规约了保证另一个类目执行的契约。

说明：在以下2个地方会使用细化关系。

1. 接口与实现它们的类和构件之间
2. 用况与实现它们的协作之间

表示：![image-20220521131836276](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20220521131836276.png)

<img src="https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20220521131910427.png" alt="image-20220521131910427" style="zoom:80%;" />



#### **依赖**

定义：依赖是一种使用关系，用于描述一个事物（如类Window）使用另一事物（如类Event）的信息和服务。

3点说明：

1. 在大多数情况里，使用依赖来描述一个类使用另一个的操作;
2. 如果被使用的类发生变化，那么另一个类的操作也会受到影响;
3. 依赖可用于其它事物之间，例如注解之间和包之间

表示：一条有向虚线

![image-20220521132125552](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20220521132125552.png)



为了进一步表达依赖的语义，UML对依赖进行了分类，并给出了相应的标记。

1. 绑定（bind）：表明源的实例化是使用目标给定的实际参数来达到的。例如，可以把模板容器类（目标）和这个类实例(源)之间的关系模型化为绑定。其中绑定涉及到一个映射，即实参到形参的映射。
2. 导出（derive）：表明可以从目标推导出源。例如类Person有属性“生日”和“年龄”，假定属性“生日”是具体的，而“年龄”是抽象的，由于“年龄”可以从“生日”导出，因此可以把这两个属性之间的这一关系模型化为导出。
3. 允许（permit）：表明目标对源而言是可见的。一般情况下，当许可一个类访问另一个类的私有特征时，往往把这种使用关系模型化为允许。
4. 实例（instanceof）：表明源的对象是目标的一个实例。
5. 实例化（instantiate）：表明源的实例是由目标创建的。
6. 幂类型（powertype）：表明源是目标的幂类型。幂类型是一个类目，其对象都是一个给定父类的子类。
7. 精化（refine）：表明源比目标更精细。例如在分析时存在一个类A，而在设计时的A所包含的信息要比分析时更多。
8. 使用（use）：表明源的公共部分的语义依赖无目标的语义。



### **UML基本关系的一般用法**

关联、泛化、实现（细化）、依赖是UML模型中可以包含的基本关系。它们也有一些变体，例如精化、跟踪、包含、扩展等。

#### **模型化简单依赖**

例如，一种常见的依赖关系是：一个类只是使用另一个类作为它的操作参数。
对此，可从含有操作的类到被该操作用做参数的类创建一个依赖。即：

![image-20220521132917569](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20220521132917569.png)

注：如果操作add和remove给出了明显的操作标记(c:Course，如上所示)，则一般就不需要给出这个依赖；但当省略操作标记时或一个模型还描述了被使用类的其它关系时，就应显示这一依赖。



#### **模型化单继承**

第一步：对于给定的一组类，发现2个或2个以上类的共同责任、属性和操作。

第二步：把发现的共同责任、属性和操作放到一个一般类中其中要注意，不要引入过多的层次。

第三步:画出从每个特殊类到一般类(父类）的泛化关系。

![image-20220521133150123](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20220521133150123.png)



#### **模型化结构关系**

**第一步**：标识关联

若对于每一个类，需要导航到另一个类的对象，那么就要在这2个类之间给出一个关联。

![image-20220521133646614](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20220521133646614.png)

例如：要了解Student所要参与的课程，因此就应在Student和Course之间给出一个关联，用于描述学生参与的课程。

上图中空心菱形标识聚合、实心菱形表示组合

若对于每一个类的对象需要与另一个类的对象进行交互，并且后一个对象不作为前一个对象的局部变量或操作参数，那么就要在这2个类之间给出一个关联。

**第二部**：对于标识的每一个关联，添加语义描述

例如，就上面的图而言，给出关联的多重性：

- 每门课程至少有一名教师，而一名教师可以教多门课程。
- 每门课程是精确地属于一个系的。

**第三步**：标识”整体/部分“

如果关联中的一个类与另一端的类相比，前者在结构上或组织上是一个整体，而后者似乎是它们的一部分，那么就要把它们标识为聚合，例如，就上面的图而言：

​	聚合：一所学校可以有0到多名学生，一个学生可以注册在一所或多所学校学习；一所学校可以有一个或多个系，而每个系只属于一个	所学校；

注意：在该例中，Department和Instructor之间有两个关联，其中：一个关联(聚合）说明可以指派一名教师到一个或多个系中工作，而一个系可以有一名或多名教师；另一关联表明一个系只能有一名教师作系主任，而某些教师不是系主任。



基本策略

- 仅当要建模的关系不是结构关系时，才使用依赖。
- 仅当关系是"is-a-kind-of”关系时，才使用泛化。
- 一般不要引入循环的泛化关系。
- 应保持泛化关系的平衡：继承的层次不要多深，不要过宽（如果出现这种情况，就要寻找可能的中间抽象类）。



## **UML-3**

### **UML模型表达工具概述**

#### **系统静态部分建模工具**

UML为不通抽象层提供了6中可对**系统静态部分**建模的图形工具：

类图、构件图、部署图、组合结构图、对象图、部署图、制品图

1. 类图：类图显示了类（及其接口）、类的内部结构以及与其他类的联系。是面向对象分析与设计所得到的最重要的模型。
2. 构件图：在转入实现阶段之前,可以用它表示如何组织构件。构件图描述了构件及构件之间的依赖关系。
3. 组合结构图：展示了类或协作的内部结构。
4. 对象图：展示了一组对象以及它们之间的关系。用对象图说明在类图中所发现的事物的实例的数据结构和静态快照。
5. 部署图：部署图展示运行时进行处理的结点和在结点上生存的制品的配置。部署图用来对系统的静态部署视图建模。
6. 制品图：展示了一组制品以及其间依赖关系。利用制品图可以对系统的静态实现视图建模。



#### **系统动态部分建模工具**

UML为不同抽象图提供了7种可对**系统动态部分**建模的图形工具。

系统动态部分：可将系统的动态部分看作是对系统变化部分的表示。正如房屋的动态方面包含了气流和人在房间中走动一样。

1. 用况图：需求模型。
2. 状态图：对象的行为比较复杂时，可用状态图作为辅助模型描述对象的状态及状态转移，从而更准确地定义对象的操作。
3. 活动图：注重从活动到活动的控制流，可用来描述对象的操作流程，也可以描述一组对象之间的协作行为或用户的业务流程。
4. 顺序图：注重于消息的时间次序。可用来表示一组对象之间的交互情况。
5. 通信图：注重于收发消息的对象的组织结构。可用来表示一组对象之间的交互情况。
6. 交互概观图：用于描述系统的宏观行为，是活动图和顺序图的混合物。
7. 定时图：用于表示交互,它展现了消息跨越不同对象或角色的实际时间，而不仅仅关心消息的相对顺序。



### **类图**

#### **定义**

类图显示了类（及其接口)、类的内部结构以及与其也类的联系，是面向对象分析和设计所得到的最重要的模型。

作用：可视化地表达系统的静态结构模型。



#### **类图的内容**

- 通常包含：类；接口；依赖、泛化和关联关系等
- 还可以包含注解和约束，以及包或子系统，甚至，可包含一个实例，以便使其可视化。

注：这些成分，确定了所表达系统的各种形态。

![image-20220522115030007](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20220522115030007.png)

举例：下图显示了某学校的信息系统的类图，该图表面，学校有多个系，每个系有多名教员，每位教员教授多门课程；该学校还有许多学生，每位学生要参加多门课。

![image-20220522115324903](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20220522115324903.png)



#### **类图的一般用法**

类图主要用于对系统的静态视图进行建模（投影），支持表达系统的功能需求，即系统提供给最终用户的服务。

创建类图包括以下四方面工作：

1. 对系统中的概念（词汇）建模，形成类图中的基本元素

   使用UML中的术语“类”，来抽象系统中各个组成部分，包括系统环境。然后，确定每一类的责任，最终形成类图中的模型元素。

2. 对待建系统中的各种关系建模，形成该系统的初始类图。

   使用UML中表达关系的术语，例如关联、泛化和依赖等来抽象系统中各成分之间的关系，形成该系统的初始类图。

   - 当用关联关系建模时，是在对相互同等的两个类建模。给定两个类间的关联，则这两个类以某种方式相互依赖，并且常常从两边都可以导航。

     1. 对于每一对类，如果需要从一个类的对象到另一个类的对象导航，就要在这两个类之间建立一个关联；

        ![image-20220522115643800](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20220522115643800.png)

     2. 对于每一对类，如果一个类的对象要与另一个类的相互交互，而后者不作为前者的过程局部变量或操作参数，就要在这两个类之间建立一个关联；

     3. 如果关联中的一个类与另一端的类相比，前者在结构或者组织上是一个整体，后者看来像它的部分，则在靠近整体的一端用一个菱形对关联修饰，从而将其标记为聚合。

        ![image-20220522115755923](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20220522115755923.png)

     4. 对于每一个关联，都要说明其多重性（特别当多重性不为\*时，其中*是默认的多重性)

   - 依赖关系是使用关系，常见的依赖关系是两个类之间的连接，其中一个类只是使用另一个类作为它的操作参数

     创建一个依赖,从含有操作的类指向被该操作用作参数的类

     ![image-20220522115944351](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20220522115944351.png)

   - 泛化关系是“is-a-kind-of”关系，在对系统的词汇建模中，经常遇到结构或行为上与其他类相似的类，可以提取所有共同的结构特征和行为特征，并把它们提升到较一般的类中，特殊类继承这些特征

     - 给定一组类，寻找两个或以上的类的共同责任、属性和操作
     - 把这些共同的责任、属性和操作提升为较一般的类
     - 画出从每个特殊类到它的较一般的父类的泛化关系，用以表示较特殊的类继承较一般的类

     ![image-20220522120056043](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20220522120056043.png)

3. 模型化系统中的协作，给出该系统的最终类图。

   使用类和UML中表达关系的术语，模型化一些类之间的协作，用类图对这组类以及它们之间的关系建模。

   例如下图显示了<font color="red">使机器人浴着一条路径移动</font>(这就是一个协作)所涉及的类

   ![image-20220522120245255](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20220522120245255.png)

   

### **用况图**

用况图是表现一组Use cases、Actors以及它们之间关系的图



#### **用况图的内容**

通常包含6个抽象：

- 主题（Subject）
- 用况（Use cases）
- 参与者（Actor）
- 依赖
- 泛化
- 关联

USE CASE图还可以包含包，形成一些更大的功能块。有时为了对一个特定的执行系统进行可视化，也把用况的实例放到USE CASE图中。

以上抽象确定了所表达的系统的各种形态。

注：为使以USE CASE图表达的系统更易理解,包含注解和约束。



#### **用况图的术语**

1. 主题

   是由一组用况所描述的一个系统或子系统。其中的这些用况描述了该主题的完整行为，而参与者则表示与该主题进行交互的另一种类。

   例如：以Credit Card Validation System所标识的矩形就是一个主题

   ![image-20220522214851557](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20220522214851557.png)

2. USE CASE（用况）

   定义：（从2个视角）

   - 使用视角：用况表达了参与者使用系统的一种方式。

     例如：”做一次拼写检查“、”对一个文档建立索引“。

     ![image-20220522215110273](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20220522215110273.png)

   - 系统设计视角

     一个use case 规约了系统可以执行的一个动作序列

     包括一些可能的变体，并对特定的操作者（actor）产生可见的、有值的结果。

     ![image-20220522215303431](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20220522215303431.png)

     注：

     1. 功能的体现：以USE CASE规约的系统功能是通过与操作者可见结果的“交互”予以体现的。即一个USE CASE捕获了参与交互的各方关于其行为的一个约定。
     2. 描述：对于一个use case的行为，可以根据具体情况，通过交互（图)、活动(图）和状态机予以描述，或通过前置条件和后置条件予以描述，或通过自然语言予以描述。

     对以后开发活动的影响：

     1. Use Case是系统分析和设计阶的输入之一，是类、对象、操作的源；并作为分析和设计一个依据；
     2. Use Case是制定开发计划，测试计划，设计测试用例的依据之一。
     3. Use Case可以划分系统与外部实体的界限，是系统开发的起点。

3. actor（参与者）

   定义：参与者是一组高内聚的角色，当用户与USE CASE交互时，该用户扮演了这一角色。

   3点说明：

   1. 一个参与者一般可以表达与系统交互的那些人（的角色)、硬件（的角色）或其它系统（的角色）。
   2. 参与者实际上不是软件应用的一部分，而是在应用的环境之中，其实例代表以某种特定方式与系统进行交互。
   3. 一个客体对象可以扮演多个参与者，例如一个人既可以是参与者LoanOffier，又是参与者Costomer。一个参与者代表了客体一个方面的角色。

   表示：![image-20220522215813099](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20220522215813099.png)

   关系：可以定义参与者之间的泛化关系，例如：

   ![image-20220522215836351](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20220522215836351.png)

4. 关系

   - 关联：参与关系，即操作者参与一个USE CASE。例如，操作者的实例与USE CASE实例相互通讯。

     关联是操作者和USE CASE之间的唯一关系。

   - 扩展：USE CASE A到USE CASE B的一个扩展关系，指出了USE CASE B的一个实例可以由A说明的行为予以扩展（根据该扩展所说明的特定条件），并依据该扩展点定义的位置，A说明的行为被插入到B中。

   - 包含:USE CASE A到USE CASE B的一个包含，指出A的一个实例将包含B说明的行为，即这一行为将包含在A定义的那部分中。

   - 泛化：USE CASE A到USE CASE B的泛化，指出A是B的特殊情况。

     注：扩展和包含是依赖的变体。

<img src="https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20220522220259491.png" alt="image-20220522220259491" style="zoom:67%;" />



#### **用况图的使用**

对系统语境建模应遵循的基本策略

- 决定哪些行为是系统的一部分，哪些行为是由外部实体执行的，以此标识系统边界，同时定义主题。

- 在标识系统的参与者时，应考虑以下问题：

  谁需要得到系统的帮助，以完成其任务；

  谁执行系统的功能；

  系统与哪些硬件设备或其他系统交互；

  谁执行一些辅助功能进行系统的管理和维护。

- 将一些相似的参与者组织为一般/特殊结构。

- 在需要加深理解的地方，为每个参与者提供一个衍型。

最后，将这些参与者放入用况图中，并建立它们与系统用况之间的关联-通信路径.



对需求建模：

对系统的需求建模应遵循的策略：

- 首先，通过标识参与者来建立系统的语境；
- 其次，对于每个参与者考虑他所期望或需要系统提供的行为。并把它们作为用况；
- 第三，通过分解用况所表达的公共行为，形成必要的泛化结构；分解异常行为，放入新的用况中以延伸较为主要的用况；
- 第四，模型化用况图中各种关系；
- 最后，通过注解和约束给出这些用况的非功能需求。

例如：

![image-20220522220829209](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20220522220829209.png)



## **UML-4**

### **顺序图**

#### **定义**

顺序图是一种交互图，即由一组对象以及这些对象之间的关系（通信）组成，其中还包含这些对象之间发送的消息。

![image-20220526214208293](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20220526214208293.png)



#### **内容**

1. 交互各方：角色或对象
2. 交互方式：同步或异步
3. 交互内容：消息

像其他图形一样，可以包含注解和约束。

这些成分确定了交互的各个形态。

从应用的角度来看，交互图是一个交互各元素（各方、方式和内容）的投影。其中把这些元素的语义应用到交互图中



说明：

![image-20220526214802140](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20220526214802140.png)

1. 对象生命线

   用于表示一个对象在一个特定的时间段中的存在。

   对象生命线表示为垂直的虚线

2. 消息

   顺序图包含了一些由时间定序的消息。消息被表示为一条箭头线，从一条生命线到另一条生命线。其中：

   - 如果消息是同步的，则用枝形箭头表示

   - 如果消息是异步的（调用），则用实心三角箭头线表示

     同步消息的回复用枝形箭头表示。

3. 顺序图中的控制结构：为了控制交互行为描述的复杂性，更清晰地表达顺序图中的复杂控制

   <img src="https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20220526220504637.png" alt="image-20220526220504637" style="zoom:67%;" />



#### **控制类型**

常见地控制类型有：

1. 选择执行（Optional execution）

   一种控制结构类型，其标签为opt。仅当进入该控制操作子（control operator），监护条件为真时，该控制操作子的体才予以执行。

   注：监护条件是一个布尔表达式，可以出现在该体中任意一个生命线顶端的方括号内，并且可以引用那个对象的属性。

   <img src="https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20220526221042830.png" alt="image-20220526221042830" style="zoom:80%;" />

2. 条件执行（Conditional execution）

   一种控制结构类型，其标签为alt。该操作子的体通过水平线将其分为一些部分。每个部分表示一个条件分支，并有一个监护条件。每一部分表示一个条件分支，并有一个监护条件。其中：

   - 若一个部分的监护条件为真，那么该部分就被执行。但是，最多一个部分可以被执行;如果多个监护条件为真时，选择哪一部分执行，这是一个非确定性的问题，其执行可以不同。
   - 如果没有一个监护条件为真，那么控制将绕过该控制操作子而继续。
   - 一个部分可以有一个特定的监护条件[else] ;对于这一部分而言，如果没有其它监护条件为真，那么该部分才被执行。

3. 并发执行（Parallel execution）

   一种控制结构类型，其标签为par。该控制操作子的体通过水平线将其分为多个部分。每一部分表示一个并行计算。在大多数情况下，每一部分涉及不同的生命线。

   - 当进入该控制操作子时，所有部分并发执行。
   - 在每一部分中的消息的发送/接受是有次序的，但在整个并发部分中的消息次序则是完全任意的。

   <img src="https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20220528105000141.png" alt="image-20220528105000141" style="zoom: 80%;" />

4. 迭代行为（iterative execution）

   一种控制结构类型，其标签为loop。监护条件出现在该体中一个生命线的顶端，只要在每一次迭代之前该监护条件为真，该循环体就反复执行。当该体上面的监护条件为假时，控制绕过该控制操作子。

   ![image-20220528105341653](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20220528105341653.png)

注：还存在其他控制操作子，但以上4种是最常用的。



### **状态图**

#### **定义**

状态图是显示一个状态机的图，其中强调了从一个状态到另一个状态的控制流。

![image-20220528110050653](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20220528110050653.png)

一个状态机是一种行为，规约了一个对象在其生存期间因响应事件并作出响应而经历的状态。



#### **内容**

内容包含：

1. 简单状态和组合状态
2. 事件
3. 转换

可以包含注解和约束

从使用的角度来看，一个状态图可以包含一个状态机中任意的、所有的特征(features)，即状态图基本上是一个状态机中那些元素(分支、结合、动作状态、活动状态、对象、初始状态、最终状态、历史状态等)的一个投影。

状态图中所包含的内容，确定了一个特定的抽象层，该抽象层决定了以状态图所表达的模型之形态



##### **状态**

1. 定义：一个状态是类目的一个实例(以后简称对象〉在其生存期间的一种条件(condition)或情况（situation），该期间该对象满足这一条件，执行某一活动或等待某一消息。

2. 表示

   <img src="https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20220528110756567.png" alt="image-20220528110756567" style="zoom:80%;" />

   

   一个状态表达了一个对象所处的特定阶段，所具有的对外呈现（外征）以及所能提供的服务。

3. 状态分类

   UML把状态分为初态、终态和正常状态：

   初态：表达状态机默认的开始位置，用实心圆来表示；

   终态：表达状态机的执行已经完成，用内含一个实心圆的圆来表示;

   初态：表达状态机默认的开始位置，用实心圆来表示;终态:表达状态机的执行已经完成，用内含一个实心圆的圆来表示;

   <img src="https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20220528111020438.png" alt="image-20220528111020438" style="zoom:67%;" />

   

   

   初态和终态都是伪状态，即只有名字。从初态转移到正常状态可以给出一些特征，例如监护条件和动作。

4. 状态的规约

   1. 名字

      是一个标识状态的文本串，作为状态名。也可以有匿名状态--没有给出状态名。

   2. 进入/退出之效应（effect）

      是进入或退出该状态时所执行的动作。

      为了表达进入/退出之效应，UML给出2个专用的动作标号：

      -  **entry**该标号标识在进入该状态时所要执行的、由相应动作表达式所规定的动作，简称进入动作。
      - **exit**该标号标识在退出该状态时所要执行的、由相应动作表达式所规定的动作，简称退出动作。

      一般情况下，进入/退出之效应不能有参数或监护条件，但位于类状态机顶层的进入效应可以具有参数，以表示在创建一个对象状态机时所要接受的参数。

   3. 状态内部转移

      是指没有导致该状态改变的内部转移。一般情况下，在此给出对象在这个状态中所要执行的内部动作或活动列表。其中表达动作的一般格式为：动作标号/动作表达式

      动作标号标识了在该环境下所要调用的动作，而该动作是通过/之后的动作表达式所规约，其中可以使用对象范围内的任何属性和链。若该表达式为空，则可省略斜线分隔符。

      为了表达状态内转换中的动作或活动，UML给出了一个专用的动作标号：do，该标号标识正在进行由其相应动作表达式所规定的活动，并且只要对象在一个状态中没有完成由该动作表达式所指定的活动，就一直执行之；当动作表达式指定的活动完成时，可能会产生一个完成事件。

      注:动作标号“entry”、"exit”和“do”均不能作为事件名。

      在以上的叙述中，使用了两个词：动作(action)和活动(activity)

      一个活动是指状态机中一种可中断的计算，中断处理后仍可继续；而一个动作是指不可中断的原子计算，它可导致状态的改变或导致一个值的返回。可见，一个活动往往是有多个动作组成的。

   4. 子状态

      如果在一个状态机中引入另一个状态机，那么被引入的状态机称为子状态机。子状态是被嵌套在另一状态中的状态。相对地，把没有子状态的状态称为简单状态；而把含子状态的状态称为组合状态。

      



剩下的太多了，不想写了。直接下载pdf后看pdf吧。再不行去mooc复习一下：https://www.icourse163.org/learn/PKU-1003177002?tid=1467032446#/learn/content?type=detail&id=1247305255&cid=1273019475&replay=true



## **面向对象分析**

### **面向对象分析概述**

面向对象分析（Object-oriented analysis，OOA）

#### **OOA的基本任务**

运用面向对象方法，对问题域（<font color='blue'>被开发系统的应用领域</font>）和系统责任（<font color='blue'>所开发系统应具备的职能</font>）进行分析和理解，对其中的事物和它们之间的关系产生正确的认识，找出描述问题域和系统责任所需的类和对象，定义这些类和对象的属性和操作，以及它们之间所形成的各种关系。最终目的是产生一个符合用户需求，并能够直接反映问题域和系统责任的OOA模型及其规约。



#### **OOA模型**

<img src="https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20220528220159916.png" alt="image-20220528220159916" style="zoom:80%;" />



#### **OOA过程**

<img src="https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20220528220431441.png" alt="image-20220528220431441" style="zoom:80%;" />



### **识别类**

#### **研究问题域和用户需求**

1. 研究用户需求，明确系统责任

   阅读：阅读一切与用户需求有关的书面材料

   交流：与用户交流，澄清疑点，纠正用户不切实际的要求或不确切的表达

   调查：到现场调查（只限于澄清需求）

   记录、整理：产生一份符合工程规范、确切表达系统责任的需求文档

2. 研究问题域

   亲临现场调查，掌握第一手资料

   听取问题域专家的见解

   阅读与问题域有关的材料

   借鉴相同或类似问题域已有的系统开发经验及文档

3. 确定系统边界

   就是划出被开发的系统和该系统打交道的人或物之间的明确界限，并确定它们之间的接口。

   在系统边界之内，是系统本身所包含的对象。在系统边界以外，是系统外部的活动者。主要是人、设备和外系统三种外部活动者。



#### **策略和启发**

1. 考虑问题域

   人员、组织、物品、设备、事件、文件、结构。。。

   - 人员：需要由系统保存和管理其信息的人员，如户籍管理系统中的每个居民；应该在系统中完成某些功能，提供某些服务的人员，如户籍管理员。符合上述情况之一者，应考虑用相应的人员对象来描述。
   - 组织：在系统中发挥一定作用的组织结构。如工作班组等。
   - 物品：需要由系统管理的各种物品。如经营的商品等。
   - 设备：在系统中动态地运行、由系统进行监控或供系统使用的各种设备、仪表、机器及运输工具等。
   - 抽象事物：指没有具体的物理形态，却对用户的业务具有实际意义的逻辑上的事物。
   - 事件：指那些需要由系统长期记忆的事件。
   - 文件：泛指在人类日常的管理和业务活动中使用的各种各样的表格、档案、证件和票据等文件。
   - 结构：通过考虑结构可以得到一种启发--从已经发现的对象联想到其他更多的对象

2. 考虑系统边界

   考虑系统边界，可以启发分析员发现一些与系统边界以外的参与者进行交互，并且处理系统对外接口的对象。

   人员、设备、外系统

   - 人员：作为系统以外的参与者与系统进行直接交互的各类人员，如系统的作员、直接使用系统的用户等。
   - 设备：作为系统以外的参与者与系统相连并交换信息的设备。
   - 外系统：与系统相连并交换信息的其他系统。

3. 考虑系统责任

   检查每一项功能需求是否有相应的对象提供，发现新的对象



#### **审查与筛选**

1. 舍弃无用对象

   通过属性判断：是否通过属性记录了一些对参与者或对系统的其他对象有用的信息?（即这个对象所对应的事物，是否有些信息需要在系统中进行保存和处理？）

   通过操作判断：是否通过操作提供了某些有用的功能?（即这个对象所对应的事物，是否有某些行为需要在系统中模拟，并在系统中发挥一份作用？）

   如果二者都不是--无用

2. 对象的精简

   只有一个属性的对象

   ![image-20220528223606062](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20220528223606062.png)

   只有一个操作的对象

   ![image-20220528223624720](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20220528223624720.png)

3. 与实现条件有关的对象

   如：图形用户界面系统、数据管理系统、硬件及操作系统有关的对象，这些都推迟到面向对象设计时考虑



#### **识别主动对象**

1. 考虑问题域和系统责任哪些对象需呈现主动行为？
2. 从需求考虑系统的执行情况是否需要并发执行？
3. 考虑系统边界以外的参与者与系统种哪些对象直接进行交互？

<font color='blue'>以上3点在分析阶段不能完全确定</font>

如果一个交互是由系统外的参与者发起的，第一个处理该交互的对象是主动对象



#### **对象分类，建立类图种的类**

1. 对象分类

   使用问题域和系统责任知识，为每一组具有相同属性和操作的对象定义一个类

2. 异常情况的检查和调整

   <font color='red'>类的属性或操作不适合全部对象实例</font>

   例如：“汽车”类的“乘客限量”属性问题：分类不够详细---进一步划分特殊类

   

   <font color='red'>属性及操作相同的类</font>

   经过抽象，差别很大的事物可能只保留相同的特征例如“吸尘器”和“电子琴”作为商品销售--考虑能否合并为一个类

   

   <font color='red'>属性及操作相似的类</font>

   考虑能否提升出一个一般类或部分类（如轿车和货车，提取增加一般类“汽车”；机床和抽风机,提取部分类“电动机”）

   

   <font color='red'>同一事物的重复描述</font>

   例如：“职员”和“工作证”--取消其中一个



### **识别属性和操作**

#### **识别属性**

##### **策略与启发**

- 按常识这个对象应该有哪些属性?（例如人的姓名、职业、地址等）

- 在当前的问题域中，对象应该有哪些属性?（例如商品的条形码）

- 根据系统责任，这个对象应具有哪些属性?（持卡人的使用地点）

- 建立这个对象是为了保存和管理哪些信息?

- 对象为了实现操作的功能，需要增设哪些属性?

  （例如传感器对象，为了实现其定时采集信号的功能，需要一个“时间”间隔属性,为了实现其报警功能,需要一个“临界值"属性。)

- 对象是否需要通过专设的属性播述其状态?

  （例如设备对象，在关闭、待命、运行、故障等不同状态将呈现不同的行为需要为其设置一个“状态”属性）

- 用什么属性表示聚合和关联?

- （对于关联，应该在关联一端的类中定义一个属性，来指出另一端的哪个对象与本端的对象发生关联,其数据类型是指向另一端对象的发针或对象标识）



##### **审查与筛选**

- 是否体现了以系统责任为目标的抽象

  （例：书的重量？）

- 是否描述对象本身的特征

  （例：课程--电话号码？）

- 是否破坏了对象特征的“原子性”

- 是否可通过继承得到？

- 可以从其他属性直接推导出的属性



##### **与实现条件有关的问题都推迟到OOD考虑**

- 规范化问题（OOA中定义的对象属性可以是任何数据类型，数据类型的规范化工作在OOD中考虑）
- 对象标识问题
- 性能问题（如果为了提高操作的执行速度，增加一些属性来保持操作的阶段性执行结果）



##### **属性命名的原则**

原则与类的命名相同：

- 使用名词或带定语的名词
- 使用规范的、问题域通用的词汇
- 避免使用无意义的字符和数字

语言文字的选择要和类的命名要一致。

定位原则：一个类的属性必须适合这个类和它的全部特殊类的所有对象，并在此前提下充分运用继承。



##### **属性的详细说明**

要在类规约中对属性进行详细说明，其中包括：属性的解释、数据类型和具体限制等。

- 属性的文字解释：例如“课程”对象的“学时”属性，其解释为“课堂讲授学时数，每学时为50分钟”
- 属性的数据类型：常用的数据类型；表示整体-部分结构或关联的属性类型可以是类或某一类对象的指针



#### **识别操作**

##### **区分对象行为的类型**

为了明确OOA应该定义对象的哪些操作，首先区分对象行为的不同类型：

1. 系统行为

   例：创建、删除、复制、转存

2. 对象自身的行为--算法简单的操作

   例：读、写属性值

3. 对象自身的行为--算法复杂的操作计算或监控

仅用于操纵类属性的操作叫做类范围的操作，其余的操作叫做实例范围的操作。



##### **发现操作的策略与启发**

1. 考虑系统责任

   要逐项审查用户需求中提出的每一项功能要求，看它应由哪些对象来提供，从而在该对象中设立相应的操作。

2. 考虑问题域

   对象在问题域对应的事物有哪些行为？

3. 分析对象状态

   对象状态的转换，是由哪些操作引起的？

4. 追踪操作的执行路线

   模拟操作的执行，并在整个系统中跟踪



##### **审查与调整**

审查对象的每个操作是否真的有用，即：

- 是否直接提供系统责任所要求的某项功能？
- 响应其他操作的请求间接地完成这种功能地某些局部操作？
- 调整取消无用地操作
- 是不是高内聚--一个操作只完成单一的、完整的功能
- 调整：
  - 拆分（一个操作中包括了多项可独立定义的功能）
  - 合并（一个独立的功能分割到多个对象操作中完成）



##### **认识对象的主动行为**

1. 考虑问题域，对象行为是被引发的，还是主动呈现的?
2. 与系统边界以外的活动者直接进行交互的对象操作
3. 根据系统责任观察系统功能的构成层次，考虑完成最外层功能的对象操作。
4. 操作执行路线逆向追踪，考察每个操作是被其它哪些对象的哪些操作请求的,直到发现某个操作不被其它成分所请求，则它应该是一个主动对象的主动操作。

OOA标注的主动对象和主动操作不一定是最终的定局，因为在OOD阶段可能增加一些新的主动对象,还可能为提高或降低系统的并发度而人为的增加或减少主动对象。



##### **操作的命名和定位**

命名：动词或动宾结构

定位：与实际事物一致

​	例如：售货员--售货、商品--出售

在一般-特殊结构中的位置

- 通用的操作放在一般类，专用的操作放在特殊类，一个类中的操作应适合这个类及其所有特殊类的每一个对象实例。



##### **操作的详细说明**

要在类规约中，要对操作进行详细说明，包括操作的解释、操作的特征标记、操作要发送的消息和约束条件等。

1. 操作的文字解释：解释该操作的作用和功能。
2. 操作名、输入输出参数、参数类型：给出操作的入口消息格式。
3. 消息发送：指出在这个操作执行时，需要请求哪些其他的对象操作。内容包括接收消息的对象类名以及执行这个消息的操作名。
4. 约束条件：操作的执行的前置条件、后置条件以及执行时间的要求等事项说明。
5. 操作流程：对于功能比较复杂的操作，要给出一个操作的流程图或活动图，表明该操作是怎样执行的。



### **识别对象之间的关系**

#### **识别继承（泛化）**

##### **识别继承（泛化）关系策略**

1. 学习当前领域的分类学知识

   因为问题域现行的分类方法往往比较正确地反映事物的特征、类别以及各种概念的一般性和特殊性。按照问题域已有的分类方法，可以找出一些与它对应的继承关系。

2. 按常识考虑事物的分类

   如果问题域没有可供参考的现行分类方法，可以按照自己的常识，从各种不同的角度考虑事物的分类，从而发现继承关系。

   例如对于“人员”可以从以下几种角度去分类：

   - 青年人、成年与老年
   - 男人与女人
   - 黄种人、白种人和黑种人
   - 在职人员与离退休人员
   - 正式职工与临时工

   从不通的角度考虑问题域中事物的分类，可以形成一些建议一般--特殊关系的初步设想，从而启发自己发现一些确实需要的一般--特殊关系

3. 使用继承的定义

   使用两种思路去发现继承关系：

   - 一种思路是把每个类看作是一个对象集合，分析这些集合之间的包含关系，如果一个类是另一个类的子集（例如“职员”是“人员”的子集，“轿车”是“汽车”的子集)，则它们应组织到同一个一般--特殊关系中。
   - 看一个类是不是具有另一个类的全部特征，这又包括以下两种情况：
     - 一种是建立这些类时已经计划让某个类继承另一个类的全部属性与操作，现在应建立继承关系来落实；
     - 另一种是起初只是孤立地建立每个类，现在发现一个类中定义的属性与操作全部在另一个类中重新出现，此时应考虑建立继承关系，把后者作为前者的特殊类，以简化其定义。

4. 考察属性导操作的适用范围

   对系统中的每个类，从以下两方面考虑它们的属性与操作：

   - 看一个类的属性与操作是否适合这个类的全部对象。如果某些属性或操作只适合该类的一部分对象，说明应从这个类中划分出一些特殊类，建立继承关系。

     <img src="https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20220529170335969.png" alt="image-20220529170335969" style="zoom:80%;" />

   - 检查是否有两个（或更多）的类含有一些共同的属性与操作。如果有则考虑，若把这些共同的属性与操作提取出来，能否构成一个在概念上包含原先那些类的一般类，形成一个继承关系。

     <img src="https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20220529170456261.png" alt="image-20220529170456261" style="zoom:80%;" />

5. 考虑领域范围内的复用

   <img src="https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20220529170818213.png" alt="image-20220529170818213" style="zoom:80%;" />

   

##### **审查与调整**

1. 问题域是否需要这样的分类?（例：书--线装书)

2. 系统责任是否需要这样的分类?（例：职员--本巿职员)

3. 是否符合分类学的常识?（用"is a kind of”去套)

   <img src="https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20220529171028896.png" alt="image-20220529171028896" style="zoom:67%;" />

4. 是否构成了继承关系?（确实继承了一些属性或操作）



##### **继承关系的简化**

1. 从一般类划分出太多的特殊类，使系统中类的设置太多，增加了系统的复杂性；
2. 建立过深的继承层次，增加了系统的理解难度和处理开销。

对继承关系的运用要适度

重点考察以下情况：

1. 取消没有特殊性的特殊类

   <img src="https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20220529171246858.png" alt="image-20220529171246858" style="zoom: 80%;" />

2. 增加属性简化继承关系（某些特殊类之间的差别可以由一般类的某个属性值来体现，而且除此之外没有太多的不同）

   <img src="https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20220529171333742.png" alt="image-20220529171333742" style="zoom:67%;" />

3. 取消用途单一的一般类，减少继承层次

   一般类存在的理由：

   - 有两个或两个以上的特殊类
   - 需要用它创建对象实例
   - 有助于软件复用

4. 调整对象层和特征层

   定义继承的活动，将使分析员对系统中的对象和类及其特征有更深入的认识，在很多情况下，随着继承的逐步建立，需要对类图的对象层和特征层进行某些修改，包括增加、删除、合并或分开某些类，以及增、删某些属性与操作或把它们移到其他类。



#### **识别关联**

##### **识别关联的策略**

1. 认识对象之间的静态联系

   考虑问题域和系统责任--哪些类的对象实例之间的关系需要在系统中表达。

2. 认识关联的属性与操作

   对于考虑中的每一种关联，进一步分析它是否应该带有某些属性和操作。就是说，是否含有一些仅凭一个简单的关联不能充分表达的信息。

   例：在教师和学生的“指导毕业论文”的关联中，是否需要给出毕业论文的题目、答辩时间、成绩等属性信息?

   如果有，则可先在关联线上附加一个关联类符号来容纳这些属性和操作，或在两个类之间插入一个类来描述这些属性与操作。

   <img src="https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20220529171745224.png" alt="image-20220529171745224" style="zoom:67%;" />

3. 分析并表示关联的多重性

   对于每个关联，从连接线的每一端看本端的一个对象与另一端的几个对象发生连接，把结果标注在连接线的另一端。

4. 进一步分析关联的性质

   若需要，使用关联角色和限定符，以详细描述关联的性质。（限定符的值用于确定该关联的另一端类的对象。即给定类的一个对象,并指定限定符内的属性值，能选定另一端类的一个对象或一组对象。）

   <img src="https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20220529171927230.png" alt="image-20220529171927230" style="zoom:67%;" />

   

   通常产品定单由定单行和一些其他描述信息组成。上图使用带有限定符的组合描述定单、定单行以及它们之间的关系。
   对于一份定单，并指定了产品名，在另一端可能有或没有一个定单与其对应。如果没有这个限定符，给定一份定单，对应的定单行可能有许多。

   <img src="https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20220529172039135.png" alt="image-20220529172039135" style="zoom:67%;" />



##### **命名与定位命名**

当关联线的语义很清晰时，则关联的命名可缺省。否则，关联可用动词或动宾结构命名。

定位问题：当连接线的某一端是一个继承结构时，要考虑连接线画到结构中的哪个类符号上。

原则：如果这个关联适应结构中的每个类的对象，则画到一般类上，如果只适应其中某些特殊类，则画到相应的特殊类上。

<img src="https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20220529172157115.png" alt="image-20220529172157115" style="zoom:67%;" />



##### **调整对象层和特征层**

在建立关联的过程中可能增加一些新的类，要把这些新增加的类补充到类图的对象层中，并建立它们的类规约。

对于每一个关联，要给出其有关性质的说明，至少要说明它所表示的实际意义。



#### **识别聚合**

##### **识别聚合的策略**

1. 物理上的整体事物和它的组成部分

   例如：机器、设备、和它的零部件

2. 组织机构和它的下级组织及部门

   例：公司与子公司、部门

3. 团体（组织）与成员

   例：公司与职员

4. 一种事物在空间上包容其它事物

   例：生产车间与机器

5. 抽象事物的整体与部分

   例∶学科与分支学科、法律与法律条款

6. 具体事物和它的某个抽象方面

   例：人员与身份、履历

7. 在材料上的组成关系

   例如，面包由面粉、糖和酵母组成，汽车是由钢、塑料和玻璃组成。



##### **审查与筛选**

1. 是否属于问题域？

   例：公司职员与家庭

2. 是不是系统责任的需要？

   例：公司导工会

3. 部分对象是否有一个以上的属性？

   例：汽车与轮胎（规格）

4. 是否有明显的整体--部分关系？

   例：学生与课程



##### **调整对象层和属性层**

定义聚合关系的活动可能发现一些新的对象类，或者从整体对象的类定义中分割出一些部分对象的类定义，应把它们加入到对象层中，并给出它们的详细说明。



#### **识别依赖**

依赖是一种使用关系，用于描述一个事物（如类Window）使用另一事物（如类Event）的信息和服务。

1. 在大多数情况里，使用依赖来描述一个类使用另一个的操作；
2. 如果被使用的类发生变化，那么另一个类的操作也会受到影响；

![image-20220529172845120](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20220529172845120.png)

建议：在初步建立类之间的关系时，可以暂时使用依赖。在最终的类图中，若能用其他关系明确地指明类之间关系的含义，就不要使用依赖。





## **面向对象设计**

### **问题域部分的概念**

#### **什么是问题域部分**

问题域是OOD模型的四个组成部分之一，是由问题域有关的对象构成，并且在特定的实现条件下提供用户所需功能的组成部分。它是在OOA模型基础上按实现条件进行必要的修改、调整和细节补充而得到的。

是对OOA模型的补充与调整

![image-20220604133002238](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20220604133002238.png)



并非所有的实现因素都能通过一些在OOD中新定义的独立组成部分而实行有效的隔离。**有些实现因素将不可避免地影响到OOA阶段识别的对象，影响到它们的内部特征和相互关系，因而要求在OOD阶段按照这些条件对它们做必要的修改、调整和细节上的补充。**这正是问题域部分的设计所要解决的问题。

1. 编程语言
2. 硬件、操作系统及网络设施
3. 复用支持
4. 数据管理系统
5. 界面支持系统



#### **为什么需要问题域部分的设计**

- 在OOA阶段只考虑问题域和系统责任，OOD则要考虑与具体实现有关的问题，需要对OOA结果的补充与调整
- 使反映问题域本质的总体框架和组织结构长期稳定，而细节可变；
- 稳定部分（PDC）与可变部分（其它部分）分开，使系统从容地适应变化；
- 有利于同一分析用于不同地设计与实现
- 支持系统族和相似系统的分析设计及编程结果复用；
- 使一个成功的系统具有超出其生存周期的可扩展性



#### **实现条件对问题域部分的影响**

现在分析和讨论各种实现条件将对OOD模型产生什么影响：

1. 编程语言

   用于实现的编程语言对问题域部分的影响最大，其中包括两方面问题：

   - 选定的编程语言可能不支持某些面向对象的概念与原则。此时要根据编程语言的实际表达能力对模型进行调整，以保证设计模型与源程序一致。
   -  OOA阶段可能将某些与编程语言有关的对象细节推迟到OOD阶段来定义。如对象的创建、删除、复制、转存、初始化等系统行为、属性的数据类型等。

   编程语言确定之后，这些问题都要给出完整的解决。

2. 硬件、操作系统及网络设施 

   选用的计算机、操作系统及网络设施对OOD的影响包括：对象在不同的站点上的分布、主动对象的设计、通信控制以及性能改进措施等。这些问题对问题域部分和控制驱动部分都将有影响。

3. 复用支持

   如果存在已经进行设计和编码的可复用类构件，用以代替OOA模型中新定义的类无疑将提高设计与编码效率。但这需要对模型做适当的调整与修改。

4. 数据管理系统

   选用的数据管理系统主要影响OOD模型的数据管理部分的设计，但也需要对问题域部分的某些类补充访问该数据管理部分所要求的属性与操作。

5. 界面支持系统

   指支持用户界面开发的软件系统。主要影响人机交互部分的设计，对问题域部分影响很少，只是两部分之间需要互传消息而已。



### **如何进行问题域部分的设计**

#### **为复用设计与编程的类而增加结构**

OOA识别和定义的类是本次开发中新定义的，需要进行编程。

如果已存在一些可复用的类，而且这些类既有分析、设计时的定义，又有源程序，那么，复用这些类即可提高开发效率与质量。

可复用的类可能只是与OOA模型中的类相似，而不是完全相同，因此需对二者进行修改。

目标：尽可能使复用成分增多，新开发的成分减少

![image-20220604142027616](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20220604142027616.png)

对第4种情况的做法：

1. 把要复用的类加到问题域。
2. 在类名后加{复用}，划掉不用的属性与操作。
3. 建立从复用类到问题域原有的类之间的泛化关系
4. 由于问题域的类继承了复用类的特征，所以有些属性和操作需要了----划掉。
5. 修改问题域原有类的结构和关联，必要时移到复用类

<img src="https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20220604142247838.png" alt="image-20220604142247838" style="zoom:67%;" />



#### **添加一般类以建立共同协议**

- 增加一般类：将所有的类组织在一起提供全系统通用的协议

  例：提供创建、删除、复制等操作

- 增加一般类：提供局部通用的协议

  例：提供永久存储及恢复功能



注意：

1. 如果新增加的类是自己定义的，则表示法和其它类一样;
2. 如果新增加的类是编程语言提供的预定义的类，则只在类符号的名字栏填写一个和语言提供的类完全相同的类名，并标上{复用}的字样，属性和操作栏不必填写任何属性和操作;
3. 在类描述模版的“类整体说明”部分的“其它"项中用文字加以说明，比如“利用编程语言提供的同名类”。

<img src="https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20220604142631606.png" alt="image-20220604142631606" style="zoom:67%;" />

上图表示“Object”是模型中新增的一般类，其它类都是模型中原有的类。这样的表示法表明，“object”是由语言提供的可复用类，实现时不需对它进行任何编程就可让A、D、E、F等类直接引用它作为一般类（B和C则通过A间接地继承。)



#### **按编程语言调整继承和多态**

起因：OOA强调如实地反映问题域，OOD考虑实现问题，所用语言不支持多继承和多态

<img src="https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20220604142929694.png" alt="image-20220604142929694" style="zoom:67%;" />

1. 对继承的调整

   方法一：采用聚合，将多继承转换为单位继承

   ![image-20220604143054992](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20220604143054992.png)

   - 保持原来多继承结构中的每个类
   - 把形成多继承的每一组特殊信息从有关的类中剥离出来，定义为部分对象类
   - 再通过聚合使各个特殊类能拥有这些信息

   一般一特殊结构和整体一部分结构在某些情况下可以互相变通的道理如下：

   尽管继承和聚合反映了现实世界中两种不同的关系，但是从最终效果来看却存在共性一都是使一个类的对象能够拥有另一个(一些)类的属性和操作。

   

   方法二：重新定义对象

   <img src="https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20220604143404831.png" alt="image-20220604143404831" style="zoom:67%;" />

2. 取消继承

   若编程语言不支持继承，有两种方法应对。

   方法一：把继承结构展平

   <img src="https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20220604143455343.png" alt="image-20220604143455343" style="zoom:67%;" />

   方法二：采用聚合的方法

   <img src="https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20220604143544912.png" alt="image-20220604143544912" style="zoom:67%;" />

3. 对多态性的调整

   ![image-20220604143615106](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20220604143615106.png)

   多态：在继承结构中，具有相同的属性和操作，在不同的类中可以具有不同的类型和行为。

   多态和重载的区别：

   重载是指相同的操作名在同一个类中可以被定义多次，按参数的个数、种类或次序等的不同对它们进行区分。

   多态是指在继承结构中，具有相同的属性和操作，在不同的类中可以具有不同的类型和行为。



#### **提高性能**

影响性能的因素：

- 数据传输时间：主要是在网络环境下不同处理机之间为完成某项系统功能进行必要的数据传输所专用的时间。影响数据传输时间的主要因素有：系统分布方案、网络拓扑结构、从发送者到接收点经由的每一段线路的传送速率和数据拥挤程度。
- 数据存取时间：是指完成一项系统功能时，在外部存储设备上读取或保存数据所用的时间。影响因素有:存储设备的物理性能(各种设备都有明确的性能指标说明)、访问外存的次数和每次访问的数据量。
- 数据处理时间：指计算机主机为完成一项功能，进行处理、计算所花费的时间。

改进性能的设计策略：

设计人员为改进性能所做的设计决策，就是对OOD模型采取某些提高性能的策略，只有这些策略仍不能满足性能要求时，才考虑改变计算机、网络、DBMS等基本配置。

- 调整对象分布：不同处理机间的数据传输成为性能瓶颈

- 合并通讯频繁的类

  ![image-20220604144027833](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20220604144027833.png)

- 增加属性以减少重复计算

- 降低算法的计算复杂性

- 用聚合关系描述复杂类

  ![image-20220604144123299](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20220604144123299.png)



#### **为实现对象永久存储所做的修改**

有些类的对象实例需要被永久存储。如果选用文件系统或关系数据库管理系统实现对象的永久存储，则需要对这些类做某些修改，如为实现对象的存储和恢复操作而增加属性和操作。这些修改在数据管理部分设计中介绍。



#### **为编程方便增加底层成分**

细化对象的分类

<img src="https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20220604144242688.png" alt="image-20220604144242688" style="zoom:67%;" />



## **敏捷开发方法**

### **敏捷开发方法概述**

#### **概念**

敏捷软件开发又称敏捷开发，**是一种应对快速变化的需求的一种软件开发能力。**

**强调开发团队与业务专家之间的紧密协作**

**面对面的沟通（认为比书面的文档更有效）**

**频繁交付新的软件版本**

**紧凑而自我组织型团队能够适应需求的变化，更注重开发中人的作用**

敏捷软件工程是哲学理念和一系列开发指南的综合。这种哲学理念推崇让客户满意和软件的早期增量发布，小而高度自主的项目团队，非正式的方法，最小化软件工程产品以及整体精简开发。开发指导方针强调超越分析和设计（尽管并不排斥这类活动）的发布，以及开发人员和客户之间主动和持续的沟通。



#### **敏捷联盟**

2001年初，由于许多公司的软件团队陷入了不断增长的过程的泥潭，一批业界专家聚集在一起概括出一些可以让软件开发团队具有快速工作、响应变化能力的价值观和原则。他们称自己为敏捷(Agile)联盟。

宣言：

- **个体和交互胜过过程和工具**
  - 人是获得成功最重要的因素
  - 一个优秀的团队成员能很好地和他人合作，即合作、沟通以及交互能力要比单纯的编程能力更重要
  - 合适的工具对成功很重要，但不要过分夸大工具的作用
  - 团队的构建比环境的构建重要得多
- **可以工作的软件胜过面面俱到的文档**
  - 没有文档的软件是一种灾难，但过多的文档比过少的文档更糟糕
  - 对团队而言，需要编写并维护一份系统原理和结构方面的文档
- **客户合作胜过合同谈判**
  - 成功的项目需要有序、频繁的客户反馈。不是依赖于合同或者关于工作的陈述，而是让软件的客户和开发团队密切地工作在一起，并尽量经常提供反馈
  - 那些为开发团队和客户的协同工作方式提供指导的合同才是最好的合同
- **响应变化胜过遵循计划**
  - 响应变化的能力常决定一个软件项目的成败
  - 计划不能考虑过远
  - 较好的做计划的策略是：为下两周做详细计划，为下三个月做初略计划，再以后就做极为初略的计划



#### **敏捷原则**

这是敏捷时间区别于重过程的特征所在

1. 最优先要做的是：通过尽早地、持续地交付有价值地软件来使客户满意。----**获取有质量软件地理念**
2. 即使到了开发后期，也欢迎改变需求。敏捷过程利用变化来为客户创造竞争优势。----**关于态度的声明**
3. 经常交付可工作的软件，其时间间隔可以是几周到几个月。交付的时间间隔越短越好。----**项目规划理念**（涉及如何处理文档和软件项目开发之间的关系）
4. 在整个项目开发期间，业务人员和开发人员必须天天在一起工作。----**团队组成和精神问题**
5. 不断激励开发人员，开展项目的有关工作。给他们提供所需的环境和支持，并信任他们能够完成所承担的工作。----**“领导”的含义-涉及管理功能**
6. 在团队内部，最有效果、最有效率的传递信息的方法，就是面对面的交谈。----**获取开发信息（需求、技术信息和项目信息等）的途径**
7. 首要的进度度量标准是工作的软件。----**进度度量理念**
8. 敏捷过程提倡可持续的开发速度。责任人、开发者和用户应该能够保持一个长期的、恒定的开发速度。----**项目“持续发展”的能力**
9. 不断关注优秀的技能和设计，增强敏捷能力。----**提高敏捷能力的一种途径**
10. 简单是根本的。----**使未完成的工作最小化的艺术**
11. 最好的体系结构、需求和设计，出自自己组织的团队。----**团队观念**
12. 每隔一段时间，团队对如何才能有效的工作进行反省，然后对自己的行为进行适当的调整。----**自我调整和适应**



### **极限编程**

极限编程（eXtreme Programming， 简称XP）是敏捷开发中最显著的一个。它由一系列简单却相互依赖的实践组成。



#### **实践原则**



1. 客户作为团队的成员

   含义：客户与开发人员一起紧密合作，相互了解所面临的问题，并共同解决问题。其中，客户（人或团队）的主要责任是定义产品特征、并对这些特征进行优先排序。

   注意：“如出现不能一起紧密工作的情况，应该寻找可以代表真正客户的、并可一起工作的人”。

2. “用户素材”（user stories）

   含义：为了了解与项目需求有关的内容，采用用户素材（user stories）---一种规划工具，作为在进行关于需求谈话时所使用的助记工具。通常，在客户的索引上记录认可的一些词语，与之同时，在该卡上写下关于需求的估算

3. 短的交付周期

   含义：短的交付周期是指每隔两周，就交付一次可工作的软件。这意味着每两周的迭代都实现了“涉众”的一些需求；并在每次迭代结束时，可给“涉众”演示由迭代所生成的系统，以得到他们的反馈。

   显然，这一实践涉及迭代计划和交付计划的定制。

4. 验收测试

   - 作用：通过验收测试，捕获用户素材的有关细节。
   - 编写时间：在要实现用户素材之前或实现用户素材期间进行编写
   - 编写工具：编写验收测试，使用能够让它自动、反复运行的某种脚本语言

5. 结对编程

   结对编程的含义是：共同设计、共同编写、功劳均等，以促进知识在全队的传播

6. 测试驱动开发

   含义：首先对产品的某一功能进行单元测试。由于该功能还不存在，因此它一定会运行失败。然后编写这一功能的代码，使得测试得以通过。

   益处：**为了测试用例通过而编写代码，这样的代码称为可测试的代码。**优点：由于要独立对它进行测试，因此可激励解除模块之间的耦合，使模块之间具有低的耦合。

7. 集体所有权

   含义：

   1. 编程中的每一结对，都具有检出（check out）任何模块的权力
   2. 没有程序员对一个特定的模块或技术单独负责；
   3. 每一个人都参与GUI工作，每一个人都参与中间件方面的工作，每一个人都参与数据库方面的工作。没有人对结对所编写的模块和技术具有更多的权威

8. 持续集成

   含义：程序员每天可以多次检入（check in）他们的模块进行集成。其中，更重要的是，要确保所有的测试都能通过；

   1. 可以把新的代码集成到代码库中，可以对代码进行合并；
   2. 必要时，可以和检入程序员进行协商。一旦集成了他们的更改，就构成了新的系统，从而要运行系统中的每一个测试，包括当前所运行的验收测试。一旦所有的测试都通过，这才算完成这一次的检入工作。

应用极限编程时间中应注意的两个问题：

1. 应将这组简单的时间融为一体，相互依赖
2. 可以增加一些实践或对其中一些实践进行修改



#### **极限编程的过程**

XP使用面向对象方法作为推荐的开发泛型，它包含了策划、设计、编码和测试4个框架活动的规则和实践

![image-20220615100237231](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20220615100237231.png)



### **敏捷设计**

#### **设计中应避免的问题**

为了应对需求变化，设计应尽力避免以下问题：

1. **僵化性**（Rigidity）：**是指难于对软件设计进行改动**，即使是简单的改动。例如：如果一个改动导致有依赖关系的连锁改动，那么设计就是僵化的。期间，必须改动的模块越多，其设计就越僵化。

2. **脆弱性**（Fragility）：**是指进行一个改动时，程序的许多地方就可能出现问题**，即使出现问题的地方与改动的地方并没有概念上的关联，即设计易于遭受破坏。

3. **粘固性**（Immobility）：**是指一部分设计中包含了对其它部分有用的成分**，但要想把这些成分分离出来就要付出很大的努力并具有相当大的风险，**即设计难于复用**。

4. **粘滞性**（Viscosity）：存在2种表现形式：

   1. **软件粘滞性**：是指面临一个改动时，若想保持系统一致的设计方法是一件很困难的事情，很易采用一些破坏设计的方法，即难于做正确的事情。
   2. **环境粘滞性**：是指环境的迟钝和低效。例如编译实践长。

5. **不必要的复杂性**（Needless Complexity）：**是指设计中包含了没有用的成分**，一方面使软件变得复杂，另一方面可使软件难于理解，即过分设计。

6. **不必要的复制**（Needless Repetition）：是指滥用“剪贴”和“粘贴”等鼠标操作。

   尽管“剪切”和“粘贴”操作也许是有用的文本编辑操作，但对代码编辑来说，该操作却是灾难性的：

   1. 往往使开发人员忽略了抽象，从而使系统不易理解；
   2. 软件中的重复代码，使系统的改动变得更加困难，不易系统的维护。

7. **晦涩性**（Opacity）：**是指模块难于理解**。并且由于代码随时不断演化，往往会使模块变得越来越晦涩。



#### **防止软件腐化的基本途径**

简而言之，以变应变，尽力避免出现以上设计问题。

进一步说：

1. 团队几乎不进行预先（up-front）设计，因此不需要一个成熟的初始设计；
2. 团队通过多次使用单元测试和验收测试，支持系统的设计尽可能的干净、简单、使设计保持灵活性和易于理解性
3. 灵活、持续地改进设计，以便使每次迭代结束时所生成的系统具有满足那次迭代需求的设计。



#### **敏捷设计方法**

包括：

​	使用一些设计原则，以保持软件是灵活的、可维护的；

​	掌握一些设计模式，以便针对特定问题权衡这些原则。

敏捷设计是一个应用原则、模式和实践的过程，其间不断改善软件结构,保持系统设计在任何时间都尽可能的简单、干净（主要是指边界清楚，结构良好）和富有表现力，即：

1. 它的功能对于用户来说，通过直观、简单的界面呈现出恰当特征的程序；
2. 它的内部结构，对于软件设计者来说，通过简单、直观的划分，使其具有最小耦合的内部结构；
3. 创造过程，对于开发人员来说，每周都会取得一些重大进展，并生产出无缺陷代码的具有活力的团队过程。



### **Scrum模型**

Scrum(得名于橄榄球比赛): Jeff Sutherland和他的团队在20世纪90年代早期发展的一种敏捷过程模型。

![image-20220616132718534](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20220616132718534.png)



#### **Scrum阶段**

Scrum有三个阶段

- 规划纲要阶：建立大致的项目目标和设计软件体系结构
- 系列的冲刺循环，每个循环开发出一个系统增量
- 项目结束阶段总结项目，完善需要的文档，如系统帮助和用户手册，并总结从项目中获得的经验。



#### **Scrum过程流**

- 待定项（backblog）：一个为用户提供商业价值的项目需求或特征的优先级列表
- 冲刺（sprint）：由一些工作单元组成，是达到特定项中定义的需求所必须的
- 演示：向客户交付软件增量

![image-20220616133247606](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20220616133247606.png)



## **软件测试-1**

### **概念**

#### **定义**

软件测试：检测和评价软件以确定其质量的过程和方法，即评价软软件或程序的属性和能力，以确定它是否满足所需结果的过程与方法。

软件测试可分为**静态测试**（检阅和审查）和**动态测试**（运行和使用软件）

1. 进行静态分析时，不必运行软件，只是通过对源代码进行分析，检测程序的控制流和数据流，以及发现执行不到的"死代码”、无限循环、未初始化的变量、未使用的数据、重复定义的数据等；也可能包括对多种复杂性度量值的计算。静态分析虽然不能取代动态测试，但它是动态测试开始前有用的质量检测手段。
2. 动态测试技术借助于输入样例(即测试用例）来执行软件，一般又分为功能测试（即黑盒测试）以及结构测试（即白盒测试）。



#### **目标**

1. 预防错误

2. 发现错误

   一般只有符合下列5个规则才叫软件错误:

   1. 软件未达到产品说明书标注的功能
   2. 产品出现了产品说明书指明不会出现的错误.
   3. 软件功能超出产品说明书的范围.
   4. 软件未达到产品说明书虽未指出但应达到的目标.
   5. 软件测试员认为软件难以理解、不易使用、运行速度缓慢，或者最终用户认为不好。



#### **软件测试和软件调试的区别**

软件调试：发现所编写软件中的错误，确定错误的位置并加以排除，使之能由计算机或相关软件正确理解与执行的方法与过程。

在进行调试工作以前，首先要发现存在着某种错误的迹象。随后的调试过程通常分为两步：

1. 确定问题的性质并且找到该错误在软件中所处的位置;
2. 修正这一错误。

主要区别：

1. 测试从一个侧面证明程序员的“失败”，而调试是为了证明程序员的正确。
2. 测试以已知条件开始，使用预先定义的程序，且有预知的结果，不可预见的仅是程序是否通过测试。调试一般是以不可知的内部条件开始,除统计性调试外，结果是不可预见的。
3. 测试是有计划的，并要进行测试设计；而调试是不受时间约束的。
4. 测试是一个发现错误、改正错误、重新测试的过程；而调试是一个推理过程。
5. 测试的执行是有规律的，而调试的执行往往要求程序员进行必要推理以至知觉的“飞跃”。
6. 测试经常是由独立的测试组在不了解软件设计的条件下完成的；而调试必须由了解详细设计的程序员完成。
7. 大多数测试的执行和设计可由工具支持，而调试时，程序员能利用的工具主要是调试器。



### **软件测试的过程模型和原则**

#### **软件测试过程模型**

![image-20220625214827808](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20220625214827808.png)

软件测试过程所涉及的要素，以及这些要素之间的关系

- 环境：包括其支持其运行的硬件、固件和软件
- 被测对象模型：为了测试，形成被测对象的简化版本。不同测试技术，对同一被测对象（程序），可产生的不同对象模型：
  - 简化注重程序的控制过程--形成”白盒“测试
  - 简化注重程序的处理过程--形成”黑盒“测试
- 错误模型：为了统一认识，定义”什么是错误“。



#### **错误、失效、故障**

- 错误（error）是指”与所期望的设计之间的偏差，该偏差可能产生不期望的系统行为或失效”。
- 失效（failure）是指“与所规约的系统执行之间的偏差”。失效是系统故障或错误的后果。
- 故障（ fault）是指“导致错误或失效的不正常的条件”。故障可以是偶然性的或是系统性的。

三者关系：

- 程序员编写程序，在这个过程中，他无意或有意地犯一个错误( error) 。
- 故障( fault）是一个或多个错误的表现。
- 当执行程序中那段有故障的代码时，就会引起失效（ failure) ，导致程序出现不正确的状态，影响程序的输出结果。



#### **软件测试原则**

1. 所有的测试都应当追述到用户需求。软件测试的目的在于发现错误，而从用户角度看，最严重的错误就是那些致使程序无法满足需求的错误。
2. 在测试工作开始前，要进行测试计划的设计。测试计划可以在需求分析一完成时开始，详细的测试用例定义可以在设计模型被确定后立即开始。
3. 测试应从小规模开始，逐步转向大规模。最初的测试通常放在单个程序模块上，测试焦点逐步转移到在集成的模块簇内寻找错误，最后在整个系统中寻找错误。
4. 穷举测试是不可能的。一个大小适度的程序，其路径排列的数量是惊人的。
5. 为了尽可能发现错误，应由独立的第三方来测试。
6. 在一般情况下，在分析、设计、实现阶段的复审和测试工作能够发现和避免80%的bug，而系统测试又能找出其余一些bug，最后剩下的bug可能只能在用户的大范围、长时间的使用后才会暴露。因此测试只能保证尽可能多地发现错误，无法保证能够发现所有的错误。



### **白盒测试**

#### **概念**

**白盒测试也称结构测试或逻辑驱动测试，它是知道产品内部工作过程，可通过测试来检测产品内部动作是否符合规格说明书的规定正常进行**，按照程序内部的结构测试程序，检验程序种的每条通路是否都有能按预定要求正确工作，而不顾它的功能

白盒测试的主要方法有逻辑覆盖、基本路径测试等，主要用于软件验证。



#### **控制流程图**

1. 关于建立被测对象模型

   控制流程图：一种表示程序控制结构的图形工具，其基本元素是节点、判定、过程块。

   其中：过程块是既不能由判定、也不能由节点分开的一组程序语句；

   ​	判定：是一个程序点，此处控制流可以分叉；

   ​	节点：是一个程序点，此处控制流可以结合。

   ![image-20220704170704023](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20220704170704023.png)

   1、3、5、6、7为过程块，2为判定，4为节点

   例如：以下为一个程序流程图，其中该例子中有两个判断，每个判断都包含复合条件的逻辑表达式。

   ![image-20220704170850537](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20220704170850537.png)

   其控制流图为：

   ![image-20220704170942992](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20220704170942992.png)

2. 各种测试方法

   该控制流程图有4条不同的路径。4条路径可表示为：

   ![image-20220704171132777](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20220704171132777.png)

   

   

#### **路径测试**

路径测试（px）：执行所有可能的穿过程序的控制流程路径。

一般来说，这一测试严格地限制为所有可能的入口/出口路径。如果遵循这一规定，则我们说达到了100%路径覆盖率。在路径测试中，该策略是最强的，但一般是不可实现的。

针对该例子，要想实现路径覆盖，可选择以下一组测试用例（规定测试用例的设计格式为:【输入的（A，B，X)，输出的(A，B，X)】) 

![image-20220704171407218](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20220704171407218.png)





#### **语句测试**

语句测试（P1）：至少执行程序种所有语句一次。

如果遵循这一规定，则我们说达到了100%语句覆盖率（用C1表达）。

在该例子种，只要设计一种能通过路径ace的测试用例，就覆盖了所有的语句。所以可选择测试用例如下：

【(2，0，4) ，(2，0，3)】覆盖L1

**语句覆盖是最弱的逻辑覆盖准则**。

问题：就该程序而言，如果两个判断的逻辑运算写错，例如，第一个判断中的逻辑运算符“∧”错写成了“∨”，或者第二个判断中的逻辑运算符“∨”错写成了“∧”，利用上面的测试用例，仍可覆盖其中2个语句，而发现不了判断中逻辑运算符出现的错误。



#### **分支测试**

分支测试(P2) ：至少执行程序中每一分支一次。如果遵循这一规定，则我们说达到了100%分支覆盖率（用C2表示)。

分支覆盖是一种比语句覆盖稍强的逻辑覆盖。但若程序中分支的判定是由几个条件联合构成时，它未必能发现每个条件的错误。

例如对于以上例子，如果选择路径L1和L2，就可得到实现分支覆盖的测试用例：

【(2，0，4),(2，0，3)】覆盖L1

【(1，1，1) ，(1，1，1)】覆盖L2

如果选择路径L3和L4，还可得另一组可用的测试用例：

【(2，1，1) ,(2，1，2)】覆盖L3

【(3，0，3) ，(3，1，1) 】覆盖L4

问题：分支覆盖还不能保证一定能查出在判断的条件中存在的错误。例如，在该例子中，若第二个分支X>1错写成X<1，利用上述两组测试用例进行测试，无法查出这一错误。因此，需要更强的逻辑覆盖准则去检验判定的内部条件。



#### **条件组合测试**

条件组合测试是一种具有更强逻辑覆盖的测试。

**条件组合测试，就是设计足够的测试用例，使每个判定中的所有可能的条件取值组合至少执行一次。如果遵循这一规定，则我们说就实现了条件组合覆盖。**只要满足了条件组合覆盖，就一定满足分支覆盖。

在条件组合覆盖技术发展过程中，最初，在设计测试用例时，人们只考虑使分支中各个条件的所有可能结果至少出现一次。但发现该测试技术未必能覆盖全部分支。例如，在上图的例子中，程序段中有四个条件:A>1，B=0，A=2，X>1。

条件A>1取真值标记为T1，取假值标记为F1
条件B=0取真值标记为T2，取假值标记为F2
条件A=2取真值标记为T3，取假值标记为F3
条件X>1取真值标记为T4，取假值标记为F4

在设计测试用例时，要考虑如何选择测试用例实现T1、F1、T2、F2、T3、F3、T4、F4的全部覆盖

例如，可设计如下车市用例实现条件覆盖：

![image-20220704172659581](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20220704172659581.png)

从上面的测试用例，可以看到该组测试用例虽然实现了判定中各条件的覆盖，但没有实现分支覆盖，因为该组测试用例只覆盖了第一个判断的取假分支和第二个判断的取真分支。为此，人们又进一步提出了条件组合覆盖技术。

例如，在该例子中，前一个判定有4种条件组合:

![image-20220704172759949](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20220704172759949.png)

可以采用以下四组测试数据，从而实现条件组合覆盖。

![image-20220704172843855](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20220704172843855.png)

这组测试用例实现了分支覆盖，也实现了条件的所有可能取值的组合的覆盖。



## **软件测试-2**

### **黑盒测试**

#### **概念**

**黑盒测试也称功能测试或数据驱动测试，它是在已知产品所应具有的功能，通过测试来检测每个功能是否都能正常使用**，在测试时，把程序看作一个不能打开的黑盆子，在完全不考虑程序内部结构和内部特性的情况下，测试者在程序接口进行测试，它只检查程序功能是否按照需求规格说明书的规定正常使用，程序是否能适当地接收输入数锯而产生正确的输出信息，并且保持外部信息（如数据库或文件）的完整性。

**黑盒测试方法主要有等价类划分、边界值分析、因果图、错误推测等，主要用于软件确认测试。**

“黑盒”法是穷举输入测试，只有把所有可能的输入都作为测试情况使用，才能以这种方法查出程序中所有的错误。实际上测试情况有无穷多个，人们不仅要测试所有合法的输入，而且还要对那些不合法但是可能的输入进行测试。

黑盒测试试图发现以下错误类型：

1. 功能不对或遗漏；
2. 界面错误；
3. 数据结构或外部数据库访问的错误；
4. 性能错误；
5. 初始化和终止错误；



#### **事物流测试**

1. 基本概念：

   事物：以用户角度所见的一个工作单元。
   一个事务由一系列操作组成。其中某些操作可含有系统执行成分，或含有设备执行成分，它们共同协作，完成用户的一项工作。

   事物处理流程（图）：系统行为的一种表示方法，为功能测试建立了软件动作模式。其中使用了白盒测试中的一些概念，例如：操作（如下图1、3、6、5）、分支（下图2），节点（下图7），链（下图中->）等。

   ![image-20220704224229625](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20220704224229625.png)

2. 与程序控制流图的比较

   1. 事务流图是一种数据流图，即从操作应用的历史，观察数据对象。

   2. 事务流图中的分支：“抽象”了一个复杂的过程。

      <img src="https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20220704224350371.png" alt="image-20220704224350371" style="zoom:67%;" />

      

   3. 事务流图存在“中断”，把一个过程等价地变换为具有繁多出口的链支。

3. 测试步骤

   第一步：获取事务流程图，即建立被测对象模型；

   第二步：浏览与复审

   ​		主要对事务进行分类，为设计用例奠定基础；

   第三步：用例设计

   ​		设计足够测试用例，实现基本事务覆盖。涉及：覆盖策略，事务选取等；

   第四步：测试设备开发：

   ​		路径分析器,测试用例数据库，测试执行调度器，...

   第五步：测试执行；

   第六步：测试结果比较。



#### **等价类划分**

1. 基本概念

   1. 等价类：输入域的一个子集，在该子集中，各个输入数据对于揭示程序中的错误都是等效的。即：以等价类中的某代表值进行的测试，等价于对该类中其他取值的测试。
   2. 有效等价类：指那些对于软件的规格说明书而言，是合理的、有意义的输入数据所构成的集合。--用于实现功能和性能的测试。
   3. 无效等价类：指那些对于软件的规格说明书而言，是不合理的、无意义的输入数据所构成的集合。--用于测试那些所实现的功能和性能不符合规格说明书的要求。

2. 等价类划分原则（指南）

   1. 如果输入条件规定了输入数据的取值范围或值的个数，则可以确定一个有效等价类和二个无效等价类。

      ![image-20220704224841871](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20220704224841871.png)

   2. 如果输入条件规定了输入数据的一组值，而且软件要对每个输入值进行处理，则可以为每一个输入值确定一个有效等价类，为所有不允许的输入值确定一个无效等价类。

      例如：对大一、大二、大三、大四的学生进行管理，可确定4个有效等价类，为大一、大二、大三、大四的学生，一个无效等价类为不符合上述身份的人。

   3. 如果输入条件是一个布尔量，则可以确定一个有效等价类和一个无效等价类。

   4. 如果输入条件规定了输入值必须符合的条件，则可以确定一个有效等价类（符合条件）和一个无效等价类（不符合条件）

      例如：”标识符是一字母打头的...串。”则字母打头的--为一个有效等价类，而其余的--为一个无效等价类

   注意：如果在已确定的等价类中各元素在软件中的处理方式不同，则应根据需要对等价类进一步进行划分。

3. 测试用例设计

   在确定等价类之后，建立等价类表：

   ![image-20220704225238486](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20220704225238486.png)

   再根据等价类来设计测试用例，过程如下：

   1. 为每一个等价类规定一个唯一的编号；
   2. 设计一个新的测试用例，使其尽可能多的覆盖尚未被覆盖的有效等价类，重复这一步，直到所有的有效等价类都被覆盖为止；
   3. 设计一个新的测试用例，使其仅覆盖一个尚未被覆盖的无效等价类，重复这一步，直到所有的无效等价类都被覆盖为止。



#### **边界值分析**

边界值分析是一种最常用的黑盒测试技术。因为测试工作经验表明，大量的错误经常发生在输入或输出范围的边界上。因此设计一些测试用例，使程序运行在边界情况附近，这样揭露错误的可能性比较大。

使用边界值分析设计测试用例可遵循以下原则：

1. 如果某个输入条件规定了输入值的范围，则应选择正好等于边界值的数据，以及刚刚超过边界值的数据作为测试数据。
2. 如果某个输入条件规定了值的个数，则可用最大个数、最小个数、比最大个数多1、比最小个数少1的数作为测试数据。
3. 根据规格说明的每个输出条件，使用前面的原则1。
4. 根据规则说明的每个输出条件，使用前面的原则2。
5. 如果程序的规格说明中，输入域或输出域是一个有序集合，在实践中，则经常选取集合的第一个元素、最后一个元素以及典型元素作为测试用例。
6. 如果程序中使用了内部数据结构，则应选择这个内部数据结构的边界上的值作为测试用例。
7. 分析规则说明，找出其他可能的边界条件。



### **软件测试的步骤**

#### **整体流程**

1. 单元测试（往往采用白盒测试技术）：集中于每个独立的模块。该测试以详细设计文档为指导，测试模块内的重要控制路径。
2. 集成测试：集中于模块的组装。其目标是发现与接口有关的错误，将经过单元测试的模块构成一个满足设计要求的软件结构。
3. 确认测试（有效性测试）：目标是发现软件实现的功能与需求规格说明书不一致的错误。（通常采用黑盒测试技术）
4. 系统测试：集中检验系统所有元素（包括硬件、软件）之间协作是否合适，整个系统的性能、功能是否达到。

![image-20220706212413797](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20220706212413797.png)



#### **单元测试**

1. 单元测试的内容

   - 主要依据详细设计说明书和源代码清单
   - 主要测试模块的i/o条件和模块的逻辑结构
   - 主要采用白盒测试方法设计测试用例，辅以黑盒测试的测试用例，使之对任何合理的和不合理的输入都要鉴别和响应
   - 要对所有的局部和全局数据结构、外部接口和程序代码的关键部分进行代码审查

   ![image-20220706212713986](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20220706212713986.png)

2. 单元测试的步骤

   1. 在代码编写完成后完成单元测试计划。根据《软件需求规格说明书》和《软件详细设计说明书》做出《单元测试计划》，建立单元测试环境。

      ![image-20220706212751752](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20220706212751752.png)

      - 驱动模块：相当于被测模块的主程序，它接收测试数据，把这些测试数据传递给被测模块，最后再输出实测结果。
      - 桩模块：由被测模块调用，用以代替被测模块所调用的子模块。

   2. 代码审查

      - 开发组、测试组和相关人员联合进行
      - 开发人员讲解自己的代码，通过checklist(检查单)方式进行错误查找
      - 一般有正式的计划、流程和结果报告

   3. 静态测试：代码走查

      - 开发人员对编写的代码进行静态分析

      ![image-20220706213008906](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20220706213008906.png)

   4. 动态测试：设计单元测试用例

      - 根据《单元测试计划》和《软件详细设计说明书》编写出《单元测试用例》
      - 着重测试模块的4个方面：模块接口、局部数据结构、重要的执行路径、错误执行路径以及4个方面相关的边界条件编写测试用例注意以下事项
        - 对于代码比较复杂的结构，首先画出控制流程图，然后尽量做到分支覆盖，核心代码要尽量做到路径覆盖
        - 在测试用例的输入数据时：尽量包括真实数据、边界数据
        - 测试语句和测试数据尽量简单，容易理解
        - 为避免对其他代码过多的依赖，可以实现简单的桩模块

   5. 执行单元测试。

   6. 书写《缺陷跟踪报告》，然后进行程序修改并进行回归测试（回归测试：是指修改旧代码后，重新进行测试以确认修改没有引入新的错误）。

   7. 书写《测试总结报告》。如果达到测试通过标准（这个指标在《测试计划》中有明确规定），则停止测试，编写《单元测试报告》



#### **集成测试**

1. 集成测试的任务
   1. 把各个模块连接起来的时候，穿越模块接口的数据是否丢失；
   2. 一个模块的功能是否对另一个模块的功能产生不利的影响；
   3. 各个子功能组合起来，能否达到预期要求的父功能；
   4. 全局数据结构是否有问题；
   5. 单个模块的误差累加起来，是否达到不可接受的程度。
2. 集成测试的方法
   1. 一次性组装方式：首先对每个模块分别进行单元测试，然后把所有模块组装在一起进行测试
   2. 增殖式组装方式：首先对每个模块分别单元测试，然后逐步组装成较大的系统，在组装的过程中边连接边测试。



#### **确认测试**

1. 确认测试的任务

   又称为有效性测试，验证软件的是有效性，即验证软件的功能和性能及其他特性是否与用户的要求一致。

2. 确认测试的步骤

   ![image-20220706213458959](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20220706213458959.png)

   

- 有效性测试是在模拟的环境（可能是开发环境）下，运用黑盒测试的方法，验证被测软件是否满足需求规格说明书列出的需求。
- 软件配置审查是保证软件配置的所有成分齐全，各方面的质量符合角球，具有维护阶段所必须的细节，并且已编排好分类的目录。



#### **系统测试**

集中检验系统所有元素（包括硬件、信息等）之间协作是否合适，整个系统的性能、功能是否达到。

系统测试实际上是一系列不同的测试，以下是用于系统测试的几种典型软件系统测试：

- 功能测试：在规定的时间内运行软件系统的所有功能，以验证这个软件系统有无严重错误。
- 恢复测试：是一种系统测试，它指采取各种人工干预方式强制性地使软件出错，使其不能正常工作，进而检验系统的恢复能力。
  - 如果恢复是自动的，则重新初始化、检测点设置、数据恢复以及重新启动等都是对其正确性的评价；
  - 如果恢复需要人员的干预，则要估算出修复的平均 时间，以及确定它是否能在可接受的限制范围内。
- 安全性测试：就是试图去验证建立在系统内的预防机制，以防止来自非正常的侵入：
  - 充当任何角色，测试者可以通过外部书写的方式得到口令；
  - 可以用用户设计的软件去破坏已构造好的任何防御的袭击系统；
  - 可以破坏系统,使系统不能为他人服务；
  - 可以跳过侵入的恢复过程,而故意使系统出错；
  - 也可以跳过找出系统的人口钥匙，而放过看到的不安全数据等；
- 强度测试：是在要求一个非正常数量、频率或容量资源方式下运行一个系统。
- 性能测试：就是测试软件在被组装进系统的环境下运行时的性能：
  - 性能测试应覆盖测试过程的每一步，即使在单元层，单个模块的性能也可以通过白盒测试来评价;
  - 性能测试有时与强度测试联系在一起，常常需要硬件和软件的测试设备。
- 可用性测试：从使用的合理性、方便性等角度对软件系统进行检验，以发现人为因素或使用上的问题。
- 部署测试（配置测试）：软件必须在多种平台及操作系统环境中运行。有时将部署测试称为配置测试,是在软件将要在其中运行的每一种环境中测试软件。另外，部署测试检查客户将要使用的所有安装程序及专业安装软件，并检查用于向最终用户介绍软件的所有文档。





## **项目管理**

### **项目管理框架要素**

#### **框架图**

![image-20220709213142244](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20220709213142244.png)

图中关键要素为项目干系人、项目管理知识领域以及项目管理工具和技术。



#### **项目干系人**

**项目干系人**是指与项目和受项目活动影响的人，包括项目发起人、项目组、协助人员、顾客、使用者、供应商，胜之书项目的反对者。人们的需要和期望在项目开始直至结束都是非常重要的。成功的项目经理都会与各项目干系人发展良好的关系，以确保对其需要和期望有较好的了解。



#### **九大知识领域**

知识领域：是指项目经理必须具备的一些重要的知识和能力。

![image-20220709213934887](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20220709213934887.png)

**项目管理的四大核心知识领域是指范围、时间、成本和质量。这四个方面会形成具体项目的项目目标：**

- 项目范围管理是确定和管理为成功完成项目所要做的全部工作。
- 项目时间管理包括项目所需时间的估算，制定可以接受的项目进度计划，并确保项目的及时完工。
- 项目成本管理包括项目预算的准备和管理工作。
- 项目质量管理是要确保项目满足明确约定的或各方默认的需要。

**四大项目管理辅助知识领域包括人力资源管理、风险管理、沟通管理和采购管理。之所以称其为辅助知识领域，是因为项目目标是通过他们来实现的：**

- 项目人力资源管理关心的是如何有效利用参与项目的人。
- 项目沟通管理包括产生、收集、发布和保存项目信息。
- 项目风险管理包括对项目相关的风险进行识别、分析和应对。
- 项目采购管理是指根据项目的需要从项目执行组织外部获取和购进产品和服务。

**项目整体管理包括在项目生命周期中协调所有其他项目管理知识领域所涉及的过程。它确保项目所有的组成要素在正确的时间结合在一起，以成功地完成项目。项目整体管理所包括的几个主要过程有：**

1. 项目计划制定：包括收集其他计划编制过程的结果，并将它们整合为一个协调一致的文件—项目计划；
2. 项目计划执行：包括通过执行项目计划所包含的有关活动，实施项目计划。
3. 整体变更控制：包括调整整个项目的变更。



#### **项目管理工具和技术**

**项目管理工具和技术**：用来帮助项目经理和项目组人员进行范围、时间、成本和质量的管理。另外也有一些工具可以帮助项目经理和项目组人员进行人力资源、沟通、风险、采购等方面的管理以及实现项目整体管理。例如，一些常用的时间管理工具和技术有：WBS（Work Breakdown Structure，工作分解结构）、甘特图（Gantt Chart）、网络图示法( Network Diagram ) 、净值图（Earned Value Chart）和关键路径法（ Critical Path Method）等。项目管理软件是一种工具，它可以应用到各个知识领域的管理过程中。

![image-20220709214613458](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20220709214613458.png)

![image-20220709214632616](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20220709214632616.png)

![image-20220709214701882](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20220709214701882.png)

![image-20220709214739035](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20220709214739035.png)



#### **项目管理的要输**

一个项目成功与否，能否抓住项目管理的要素是关键。项目管理的要素包括项目的范围、进度、成本和质量：

- 范围

  项目的范围在项目管理中也称为工作范围，是指为了实现项目目标必须完成的所有工作。一般通过定义交付物和交付物标准来定义工作范围。工作范围根据项目目标分解得到，它指出了“完成哪些工作就可以达到项目的目标”，或者说“完成哪些工作项目就可以结束了”。后一点非常重要，如果没有工作范围的定义，项目就可能永远都做不完。要严格控制工作范围的变化，一旦失控就会出现“画蛇添足”的尴尬局面。

- 进度

  项目的进度不仅说明了完成项目工作范围内所有工作需要的时间，也规定了每个活动的具体开始时间和结束时间。项目中的活动根据工作范围确定，在确定活动的开始和结束时间时，还需要考虑它们之间的依赖关系。

- 成本

  项目的成本是指完成项目需要的所有资金，包括人力资源成本、原材料成本、设备租金、分包费用和咨询费用等。项目的总成本以预算为基础，项目结束时的最终成本应该控制在预算内。而且需要注意的是，在软件项目中人力资源成本的比例很大，而工作量又难以估计，因此制定预算时难度很大。

- 质量

  项目的质量是指项目满足明确或隐含需求的程度，一般通过定义工作范围中的可交付物的标准来明确定义。这些标准包括各种特性及这些特性需要满足的要求，因此交付物在项目管理中有重要的地位。另外，有时还可能对项目的过程有明确要求，比如规定过程应该遵循的规定和标准，并要求提供这些过程得以有效执行的证据

项目的目标就是按照指定的成本和进度交付具有一定质量的指定范围的产品。



#### **项目的生命周期**

![image-20220709215130048](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20220709215130048.png)

