数据结构

## 序言

> 本数据结构（c描述）系列笔记需要c语言基础知识，学习数据结构需要非常牢靠的c语言基础
>
> 所谓基础不牢，地动山摇。在正式学习数据结构之前本系列笔记会将在数据结构中经常用到的C语言指针、函数调用、数组、结构体等数据结构预备语法进行梳理和复习。其他C语言语法请广大网友们上网学习



## 指针基本概念

### **引例1：答疑教室**

问题描述：

> 期末考试前，主讲教师在最后一节课通知学生下周会有助教答疑，但是答疑教室还没有确定。主讲教师告诉学生：答疑那天，在教研室的黑板上会有答疑教室的房间号。假设学生已经知道教研室的房间号为102，请问怎样找到助教？

●**设答疑教室用room表示，教研室用p表示**。对于学生来说，教研室p的位置已知，学生可先通过p找到教研室，然后查看到黑板.上老师填写的门牌号106，从而可以得知答疑教室room的所在位置，然后找到助教。

●答疑教室的房间号相当于变量room的地址。由于变量room的存储地址存放在变量p中，则可以通过变量p取出变量room的存储地址，从而实现对变量class的**间接**访问。

![image-20211011224621296](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20211011224621296.png)



我们把这个问题转化为代码

```c
#include <stdio.h>
int main()
{
    int room = 1582;    //假设助教的教师编号是1582
    int *p = NULL;      //变量p是指向int型数据的指针，初始化为空
    p = &room;          //使指针p存储变量room的地址
    printf("教室房间编号是:%X\n",p);   //以十六进制输出指针p的值
    printf("助教教师编号是：%d\n",*p);  //输出指针p所指的变量
    return 0;
}
```

运行结果：

![image-20211011234409371](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20211011234409371.png)

> 教室编号表示答疑助教。用**取地址运算符&**获取变量room的地址并赋给指针变量p，再通过指针p访问变量room

![](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20211011224607669.png)



### **指针的概念**

为了正确理解指针，必须在机器层面理解变量在内存中的存储方式，深刻理解变量地址的含义。

![image-20211011224536800](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20211011224536800.png)

一个int类型的变量占用4个字节的存储空间，如左图中我们将10赋值给变量x，变量x的内存地址为B000到B003，我们将这**4个字节的首地址作为变量x的地址**右图中我们将变量x的起始地址存储在变量p中，我们就可以通过变量p得到变量x的内存地址，通过内存地址访问变量x



### **指针变量的定义**

`基类型 *指针变量名`
例：`int *p;`

"*"为指针定义符

- 其中，基类型是该指针变量指向内存单元的数据类型，可以是任意合法的数据类型;“*”称为指针定义符，用来说明指针变量以区别于普通变量;指针变量名是合法的标识符。
- 含义:定义一个指向基类型的指针变量，编译器为指针变量分配存储空间。



###　**与地址相关的运算符**

取地址表达式的一般形式：`&变量`

- 含义:获得变量的存储地址。
- 注意，取地址运算符的运算对象只能是变量。

间接引用运算符“*”的一般形式：`*指针变量`

- “*”称为间接引用运算符;
- 指针变量必须指向某个确定的存储单元。
- 含义:访问指针变量所指存储单元。

```c
int room = 1582;
int *p = NULL;
p = &room;
printf("教师编号是：%d\n",*p);
```

运行结果：![image-20211011224837586](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20211011224837586.png)



### **指针变量定义要注意的问题**

1. 定义指针变量时需要明确该指针所指向的数据类型，即该指针所指向的内存单元可以存放什么类型的数据，对指针变量的运算与它所指向的数据类型密切相关。

   ![image-20211011225203939](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20211011225203939.png)

   **说明**:因为指针中只能存放x变量的“**首地址**”，因此`int *p;`这个定义，实际上是告诉计算机以“访问整形数据”的方式“看待”内存。也就是说，先通过p找到x所在内存的开始位置，然后因为p只能访问整数，所以一次性从内存中取出4个字节进行访问。

2. 定义指针变量时，“\*”是指针定义符，用来说明该变量是指针变量;对指针所指变量进行间接访问时，“\*”是间接引用运算符，用来访问指针所指存储单元。

   ![image-20211011225715422-16339642679661](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20211011225715422-16339642679661.png)

   - 很多同学容易混淆两种“\*”号的用法，只要记住下面这点:首先出现的*p，用来声明p是指针;
   - 当p被定义为指针后，再次出现的*p，表示获得p所指单元的内容。

3. 指针变量存放该指针指向变量的存储地址，内存地址通常是一个无符号整数，因此，所有指针变量占有相同大小的存储空间，具体的存储单元数与计算机系统和编译器有关。

   - 在32位的操作系统中，指针变量占有32bit的内存单元;
   - 在64位的操作系统中，指针变量占有64bit的内存单元;



### **变量的访问方式**

- 直接访问:通过变量名对变量所占存储单元进行访问（即存取操作），这种访问方式称为直接访问。

  ![image-20211011230345529](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20211011230345529.png)

  ```c
  int x=10;	/*对变量x进行存操作，x体现左值特征——变量的地址*/
  ```

- 间接访问:通过指针对指针所指向变量的存储单元进行访问，这种访问方式称为变量的间接访问

  ```c
  int x = 10,y;	
  int *p = &x;	/*指针p指向变量x*/
  *p = 10;		/*对变量x的间接访问——存操作*/
  y = *p;			/*对变量x的间接访问——取操作*/
  ```

  ![image-20211011230804071](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20211011230804071.png)



### **指针的初始化**

`int *p;`
`int *p=NULL;`

- 初始化指针变量可以将变量的存储地址或是另一个已经定义的指针赋给该指针变量。

  ```c
  int x = 10;
  int *p = &x;	/*指针p指向变量x */
  int *q = p;		/*指针q指向变量p所指向的变量x*/
  ```

  ![image-20211011231251162](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20211011231251162.png)

- 系统为变量p 分配存储空间，由于尚未给指针变量p赋值，则指针变量p是“值无定义的”，可能指向内存中任何位置这种指针称为野指针。

- 野指针在程序中是很危险的，可能会引发系统崩溃。

- 良好的编程习惯是初始化为空指针NULL。

> 在为指针变量初始化时，赋值运算符左侧内存地址的数据类型应该与基类型一致。

错误案例：

![image-20211011231534368](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20211011231534368.png)



### **指针变量的赋值操作**

```c
int x = 10;
int *p = NULL, *q = NULL;	/*指针p和q均初始化为空*/
p = &x;						/*指针p指向变量x*/
q = p;						/*指针p指向变量x*/
```

> 令把一个变量的地址赋给指针变量时，该变量必须在此之前已经定义，因为变量只有在定义后才能被分配存储单元
>
> 指针变量的赋值需要注意赋值的相容性，只有基类型相同的指针变量才可以相互赋值





```c
int *p = NULL;		/*p为指向int型数据的指针变量*/
p = 100;			/*产编译器会给出警告*/
```

> 通常不允许将一个整数赋给指针变量，由于指针的操作需要编程人员保证其安全性，编译器通常只会给出一个警告。



#### **通用指针**

通用指针是可以指向任意类型数据的指针

定义通用指针的一般形式：`void *指针变量名`

- 其中，“、*”是指针定义符;void*表示通用指针；指针变量名是一个合法的标识符。
- 含义:定义通用指针，编译器为该指针变量分配存储空间。

![image-20211011232509819](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20211011232509819.png)



## 指针与函数传参

### **引例：数据交换问题**

阅读下面两段程序，理解并分析为什么会有不同的运行结果

```c
#include <stdio.h>
void swap(int x,int y)
{
    int temp = x;
    x = y;
    y = temp;
}
int main(){
    int x = 5, y = 9;
    printf("swap函数调用前：x=%d y=%d\n",x,y);
    swap(x,y);
    printf("swap函数调用后：x=%d y=%d\n",x,y);
    return 0;
}
```

运行结果：![image-20211012113840046](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20211012113840046.png)

这是一段非常简单的数据交换函数，在主函数中定义了整型变量x，y并赋初值5和9。通过swap函数将main函数的x，y传入swap函数的x，y中做数据交换。
那么为什么执行swap函数前后的x和y的值是一样的呢？

一开始进入main函数中系统会为x和y分配内存空间并赋初值5和9，当我们调用swap函数时会把实际参数x，y的值（**注意是传递的是x、y的值，而不是x、y本身**）5和9传给swap的形式参数x，y（main函数的x、y和swap函数的x、y的作用域是**独立**的互不影响的，属于两块不同的内存空间）；系统会为swap函数额外分配一块内存空间，就包含形式参数x、y，temp，它们的作用域仅在swap函数的花括号内

![image-20211012120651515](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20211012120651515.png)

当swap函数执行完了之后，为swap函数分配的内存空间也就会被回收，而在swap函数中并没有做任何返回值的操作，并不影响main函数中的实际参数x、y所以执行swap函数前后x和y的值是一样的

这段程序的传参方式，我们称之为“**传值方式**”

> 总结：虽然在swap函数中，我们对x, y的值进行了交换，但是这个交换的结果并没有影响到实参x, y，因此x, y的值仍然是原来的x=5, y=9。



```c
void swap(int *p1,int *p2)
{
    int temp = *p1;
    *p1 = *p2;
    *p2 = temp;
}  

int main()
{
    int x = 5, y = 9;
    printf("swap函数调用前：x=%d y=%d\n",x,y);
    swap(&x,&y);
    printf("swap函数调用后：x=%d y=%d\n",x,y);
    return 0;
}
```

运行结果：![image-20211012121302987](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20211012121302987.png)

在swap函数中我们定义了int类型的指针变量p1、p2，并交换了p1、p2所**指向内存空间**的值（这一点不理解的小伙伴就要返回去好好看看指针的内容了）

在main函数中调用swap时（`swap(&x,&y);`）用“&”将x、y的地址传给swap的形式参数p1、p2，现在p1指针中内容是x的内存地址，p2指针中的内容是y的内存地址，通过更改x、y存储空间的值来交换数据

这段程序的传参方式我们称之为“**传地址方式**”

传地址方式的要点: 
main函数和swap函数**共用x, y变量的存储空间**，只不过在main函数中，用x,y访问此空间;而在swap函数中，则用p1,*p2这种间接访问方式访问此空间。由于空间是共用的，所以形参\*p1,*p2发生了改变，也就影响到了实参x, y。

> 总结：在这个swap函数中，我们利用p1,p2对x, y的“间接访问”方式，使得x, y的值发生了交换。



### **传值方式**

- 在**函数定义**时，将形参定义为普通类型（即非指针类型），实参可以是类型与形参相容的常量、变量或表达式;

- 在**函数调用**时，系统为形参分配存储空间，然后将实参的值传递到形参中;

- 在**调用结束**后，系统自动释放形参的存储空间

- 值传递方式的特点:

  被调用函数的执行**不影响函数的实参**，即在被调用函数中不能对函数的实参进行修改，因此，通常以值传递方式实现函数的输入。



### **传地址方式**

- 在**函数定义**时，将形参声明为指针类型，实参可以是基类型与形参相容的指针或变量地址;

- 在**函数调用**时，系统为形参分配存储空间，并将实参的值（即地址）传递到形参中;

- 在**调用结束**后，系统自动释放形参的存储空间。

- 指针传递方式的特点:

  在被调用函数中可以对实参地址所对应的存储单元进行访问，即可以读取或修改该内存单元的值。因此，可以通过指针传递方式实现函数的输出，即将被调用函数修改的值传递（返回）给调用者。





## 指针与一维数组

### **引例1：顺序查找**

- 要求用指针实现:在整数集合r中顺序查找与给定值key相等的元素。
- 用一维整型数组a[n]存储整数集合，顺序查找从数组的第一个元素开始，依次比较每一个元素，直至找到key为止，如果数组的全部元素都比较完,说明查找失败。

![image-20211014202811692](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20211014202811692.png)



#### **代码实现**

##### **数组实现方式**

```c
#include <stdio.h>
#define N 6                     // 假设数组有N个元素
int main(){
    int a[6] = {2,4,8,6,5,3};
    int i;
    int key = 8;                // 假设带查找的元素为8
    int index = 0;
    for (i=0;i<N;i++){
        if (key == a[i]){
            index = i;          // 找到退出循环，把下标赋给index
            break;
        }
    }
    if (i == N) index = -1;     // 没找到，index值赋为-1
    if (index == -1){
        printf("查找失败！\n");
    } else{
        printf("查找成功,元素%d在集合中的序号是%d\n", key, index);
    }
    return 0;
}
```

运行结果：![image-20211014204011715](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20211014204011715.png)

遍历数组当，将数组中的每个元素与key做比较，如果相等将下标赋值给index 并退出循环，当i=6时 证明在数组中没有找到该元素将index值赋为-1。



##### **指针方式实现**

```c
#include <stdio.h>
#define N 6
int main(){
    int a[N] = {2,4,8,6,5,3};
    int index=0;
    int *p = NULL;              // 定义整型指针暂时指向NULL
    int key = 8;                // 假设要查找的值为8
    for (p=a;p<a+N;p++){        // 使指针p指向数组a的首地址，
        if (*p == key){
            index = p - a;      // 找到元素将下标赋值给index
            break;
        }
    }
    if (p == a+N) index = -1;
    if (index == -1){
        printf("查找失败!\n");
    } else{
        printf("查找成功,元素%d在集合中的序号是%d\n", key, index);
    }
    return 0;
}
```

在理解这段程序之前我们需要弄明白几件事：

1. `int *p=NULL;`时的“\*”是指针表定义符，表示p是一个指针变量

2. `p=a`是把a的地址赋值给指针变量p，这是p中存放的就是a的地址

3. `*p == key`这是在p前面添加“\*”表示指针变量**p所指向地址的值**

   如果上面3点还没弄明白的小伙伴就要好好看看博主之前发的[指针的基本概念](http://strongforu.top/archives/253)这篇帖子了

4. `int a[N] = {2,4,8,6,5,3};`定义数组时，a不光是数组名还是该数组的首地址；如果不理解的小伙伴就看看下面的例子，理解的小伙伴就直接跳过吧

   ```c
   #include <stdio.h>
   #define N 6
   int main(){
       int a[N] = {2,4,8,6,5,3};
       int *p = a;
       printf("a的值为：%X\n",a);
       printf("&a的值为：%X\n",&a);
       printf("p的值为：%X\n",&a);
       printf("&a[1]的值为：%X\n",&a[1]);
       printf("&a[2]的值为：%X\n",&a[2]);
       p += 1;
       printf("p += 1后p的值为：“%X\n",p);
       p += 1;
       printf("p再次 += 1后p的值为：“%X\n",p);
       return 0;
   }
   ```

   运行结果：![image-20211014211617864](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20211014211617864.png)

   我们可以看到，变量a前没有加取地址符”&“时值为61FDF0，加了取地址符”&“后地址还是61FDF0，同时`int *p = a;`定义指针变量p时赋初值为a；因为a是数组名，**本质上存放的也是地址**，所以我们给p赋初值是没有像以前一样在变量前面加取地址符”&“（**数组变量本质上也是一个指针，指向的是数组的首地址**）

   而a[1]、a[2]的地址分别为61DF4、61DF8，这是应为我们定义的是整型数组，一个整型在C语言中占**4个字节**

   指针变量p指向数组后再执行`p+=1`p就会指向到数组中的下一个元素的，这一点可以从上面的代码验证

搞明白上面4点之后这段程序就已经弄懂一大半了，`for (p=a;p<a+N;p++)`循环的终止条件为 p<a+N ;a+N运算后的结果是数组首地址a
向后偏移6×4个字节后的值（数组中有6个元素，每个元素为整型，占4个字节）
`index = p - a`因为指针变量p赋初值为数组a，p经过几次自增运算后在减去a结果为p向后偏移的次数，也就是数组的下标了（这一点点比较难理解，小伙伴们多体会一下，实在不能理解就死记硬背吧）



### **用指针访问一维数组**

对一维数组元素的访问共有三种方式

1. 通过下标访问数组元素

   ```c
   int a[10];
   for (int i=0;i<10;i++)
       a[i]=i;
   ```

2. 通过地址访问数组元素

   ```c
   int a[10];
   for (int i=0;i<10;i++)
       *(a+i)=i;
   ```

![image-20211014215937957](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20211014215937957.png)

3. 通过指针访问数组元素

   ```c
   int a[10];
   int *p=a;
   for (int i=0;i<10;i++)
       *(p+i)=i;
   ```

   ![image-20211014220058977](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20211014220058977.png)

`a[i]`、`*(a+i)`、`*(p+i)`三者之间是等价的，前提是p和a都指向数组的首地址；p和a之间的区别在与p指针可以移动指向下一个地址，但是a是不能++的，a是一个常量，保存了数组的首地址。

p++自增运算要比p+i算术运算快得多，因此其执行效率比地址方式高。我们在编写程序时更推荐使用p++

```c
int a[10];
int *p=a;
for (int i=0;p<(a+10);i++,p++)
    *p=i;
```

![image-20211014220823645](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20211014220823645.png)

p++是什么意思呢？p一开始指向数组a的首地址，数组a是整型数组，一个元素占4个字节，p++后p指针会向后偏移4个字节指向a[1]，再次p++后又向偏移4个字节指向a[2]

循环的终止条件为`p<(a+10)`，每循环一次就会指向下一个数组元素，当p扫描完数组后会刚好指向数组a的有效范围外也就是a+10那



### **指针变量的算术运算**

- **指针与整数的加减**运算。对指针变量加上或减去一个整数,表示将该指针后移或前移确定的存储单元。

- **两个同类型指针的减法**运算。对两个相同类型的指针变量进行减运算,表示这两个指针间有多少存储单元。

- 对指针变量加上或减去一个浮点数、进行乘、除等算术运算、对两个指针变量进行加、乘、除等算术运算通常没有实际意义。

- 因为数组占用一段连续的内存空间，因此，指针的算术运算通常用于数组。

  ```q
  int num,a[5]={1,2,3,4,5}
  int *p=a,*q;		// 指针p指向元素a[0]
  q=p+4;				// 相当于q=p+4× sizeof(int)，将q指向a[4]
  num=q-p;			// 指针q和p之间的元素个数，值为4
  num=(int)q-(int)p;	// /指针q和p之间的字节数，值为16
  ```



### **指针变量的关系运算**

- 同类型的指针之间进行比较运算。
- 不同类型的指针之间、指针与非0整数之间的关系运算没有实际意义。
- 假设p和q是两个同类型的指针变量，则
  - p==q：判断指针p和q是否指向同一存储单元
  - p >q：指针p所指存储单元在指针q所指存储单元的后面
  - p !=NULL：判断指针p是否为空指针
- 通常对指向同一数组中的指针变量之间进行比较大小具有实际意义。
- 如果表达式p>q成立，则指针p所指数组元素在指针q所指数组元素的后面;
- 假设数组a有10个元素，如果表达式p<a + 10成立，则指针p指向数组中某元素。



### **引例2：一维数组作为函数的参数**

- 输入10个整数，将其中最小的数与第一个数交换，把最大的数与最后一个数交换。
  - ·程序运行结果范例）:
  - 请输入10个整数：2 3 4 23 5 78 0 1 6 12
  - 交换后的结果为：0 3 4 23 5 12 2 1 6 78
  - 请输入10个整数：1 25 7 40 5 6 12 8 30 19
  - 交换后的结果为：1 25 7 19 5 6 12 8 30 40
- 用数组及数组传参方式实现上述程序。
  - 写3个函数:(1)输入10个数;(2)进行处理;(3)输出10个数。
  - 这个程序使用数组和指针两种方法实现。



#### **代码实现**

##### **数组实现方式**

```c
#include <stdio.h>
// 输入数组函数
void inputArray(int arr[],int num){
    printf("请依次输入10个数：\n");
    for (int i = 0; i < num; i++) {
        scanf("%d",&arr[i]);
    }
}


// 输出数组函数
void outputArray(int arr[],int num){
    for (int i = 0; i < num; i++) {
        printf("%d ",arr[i]);
    }
}

// 交换函数
void swap(int *p1,int *p2)
{
    int temp = *p1;
    *p1 = *p2;
    *p2 = temp;
}


void process(int arr[],int num){
    int minNum = arr[0];        // 将第一个数设置为最小数
    int maxNum = arr[0];        // 将第一个数设置为最大数
    int maxPos = 0;             // 记录最大数的位置
    int minPos = 0;             // 记录最小数的位置

    for (int i=0;i<num;i++){
        if (arr[i]< minNum){
            minNum = arr[i];
            minPos = i;        // 记住最小数的下标
        }
        if (arr[i] > maxNum){
            maxNum = arr[i];
            maxPos = i;        // 记住最小数的下标
        }
    }
    if (minPos != 0) {
        swap(&arr[0],&arr[minPos]);  //若最小数不是第一个数,将最小数和第一个数交换
    }

    if (maxNum != num-1) {
        swap(&arr[num-1],&arr[maxPos]);  //若最大数不是最后一个数,最大数和最后的数交换
    }
}


int main(){
    int arr[10];
    inputArray(arr,10);
    process(arr,10);
    outputArray(arr,10);
}
```

需要注意的是，当我们将数组作为参数传递给函数时，我们需要**传递两个参数**，一个是数组，一个是数组长度

##### **指针方式实现**

```c
#include <stdio.h>
// 输入数组函数
void inputArray(int arr[],int num){
    printf("请依次输入10个数：\n");
    for (int i = 0; i < num; i++) {
        scanf("%d",&arr[i]);
    }
}


// 输出数组函数
void outputArray(int arr[],int num){
    for (int i = 0; i < num; i++) {
        printf("%d ",arr[i]);
    }
}

// 交换函数
void swap(int *p1,int *p2)
{
    int temp = *p1;
    *p1 = *p2;
    *p2 = temp;
}

void process(int *arr,int num){
    int *p = NULL;      // p指针向后移动扫描数组
    int *max,*min;      // min和max指针记录最小和最大数的地址
    p=arr=max=min;      // max,min均指向数组第一个数

    for (;p<arr+num;p++){
        if (*p < *min)  min = p;        // 记住最小数的位置
        if (*p > *max)  max = p;        // 记住最大数的位置
    }

    if (min != arr) swap(arr,min);      // 如果最小数不是第一个数，则交换
    if (max != arr+num-1) swap((arr+num-1),max);        //如果最大数不是最后一个数，则交换
}


int main(){
    int a[10];
    inputArray(a,10);
    process(a,10);
    outputArray(a,10);
}
```

在定义子程序时`void process(int arr[],int num)`和`void process(int *arr,int num)`这两种方式是一样的

![image-20211014232927600](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20211014232927600.png)

> 一维数组作为参数的特点是：**形参数组和实参数组是同一个数组**。也就是说，主程序和子程序分别用不同的名字，共用了同一块空间。因此在子程序中，通过arr[i]对数组的任何改变，都会相应的影响到对应的实参a[i]。





## 指针与二维数组

这里先说一下，这一部分的内容有点难，而博主的表述能力有限，如果没有看懂的小伙伴不必强求，直接跳到网页底部看看视频吧

 ###　**用指针访问二维数组**

如何理解二维数组?我们以二维的方式理解二维数组它在**存储时却是一维**的。

例如：`int a[3][4]={1,3,5,7,9,11,13,15,17,19,21,23};`

我们想象中是这样的：
![image-20211017193629893](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20211017193629893.png)

二维数组在物理内存中实际的存储方式是一维的：
![image-20211017193955216](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20211017193955216.png)

实际上，这个**二维数组可以被看成只有三个元素**:a[0],a[1],a[2]。每个元素都是一个包含了**四个整数的一维数组**。换而言之，C语言把数组a看成里面有3个元素的数组，这三个元素的名字分别叫做：a[0],a[1],a[2]；a[0],a[1],a[2]都是包含4个整数的一维数组。



### **通过指针访问二维数组的不同形式**

把二维数组的每一行看成是一个一维数组，其中每个数组元素是一个一维数组：
这里我们又引出了两个概念：行指针和列指针

![image-20211017194718697](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20211017194718697.png)

`a`是等于`a+0`的，是一个**行指针**，指向的是数组a中a[0]这个元素，而a[0]是一个一维数组。

我们知道在一个指针变量前面加一个“\*”例如`*p`意思是把指针p所指向的元素取出来，那么`*(a+0)`也就是把**a的所指向的元素取出来**，而a指向的是一个一维数组，所以这时`*(a+0)`就是一个**列指针**，**指向的是一维数组a[0]中的第一个元素**。

`*(a+0)`指向的是一维数组a[0]的第一个元素，那么指向一维数组a[0]的第二个元素就是`*(a+0)+1`，指向第三个元素就是`*(a+0)+1`

![image-20211017201259100](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20211017201259100.png)

理解了上面的内容之后我们来看看下面两个案例：

```c
int  a[3][4];
int *p = a;		// 编译错误，无法实现类型转换
```

a是一个行指针，看待元素的角度是每一个元素都是一维数组，而我们定义指针p时定义的是整数指针，它们俩的类型不一样，所以这样写是错误的

```c
int a[3][4];		// 正确
int *p = a[0];
```

```c
int a[3][4];
int *p = &a[0][0];	//	正确
```

a[0]是一维数组的首地址，它看待数组元素的角度是每个元素都是整数，是指向整数的指针，p也是指向整数的指针，所以可以赋值。

我们也可以将一个具体的地址编码（a[0\][0]）赋值给指针p。a[0]\[0]是一个存放的是一个整数，p是指向整数的指针，所以可以赋值。



### **用指针访问二维数组四种方式**

二维数组元素的访问可以有四种方式：

1. 通过下标访问数组元素

   ```c
   int a[3][4];
   for (int i=0;i<3;i++){
       for (int j=0;j<4;j++){
           a[i][j]=i+j;
       }
   }
   ```

   ```c
   int a[3][4];
   for (int i=0;i<3;i++){
       for (int j=0;j<4;j++){
           *(*(a+i)+j) = i+j;
       }
   }
   ```

2. 通过数组首地址访问数组元素
   - 对于二维数组元素a[i]\[j]，“[]”实际上是变址运算符，即将元素a[i]\[j]的存储地址转换为a[i] +j。

3. 通过指针访问数组元素

   以一维数组的角度看待二维数组

   ```c
   int a[3][4];
   int *p = &a[0][0];
   for (int i=0;i<3;i++){
       for (int j=0;j<4;j++){
          *(p++) = i+j;	//相当于*p=i+j; p++;
       }
   }
   ```

   在这里,指针p被定义为：“指向int的指针”，也就是说:**p指针“认为”它指向的是一个一维数组，每个元素都是int型的，共有12个元素**。

4. 通过指针访问数组元素

   以二维数组的角度看待数组

   ```c
   int a[3][4]={1,3,5,7,9,11,13,15,17,19,21,23};
   int (*p)[4];
   for (int i=0;i<3;i++){
       for (int j=0;j<4;j++){
          	*(*(p+i)+j) = i+j;
       }
   }
   ```

   ![image-20211017205248365](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20211017205248365.png)

   指针这样定义之后，**指针p将以和数组a完全相同的视角的区看待二维数组**。也就是说，a可以怎么使用，p也可以同样的使用。例如：此处`*(*(p+i)+j)`可以替换为p[i]\[j],a[i]\[j],`*(*(a+i)+j)`都是等价的。



### **指向字符串的二维数组**

```c
char *str[3] = {"Red","Green","Blue"};
```

![image-20211017205408506](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20211017205408506.png)

在C语言中"[]"的优先级是高于“*”的，所以上面语句中str先被定义为长度为3的数组，而数组中存放的类型是字符指针，所以str是一个指针数组，数组中的指针指向的是字符串常量“Red”、"Green"、"Blue"的首地址。



### **二维数组做为函数的参数**

#### **引例：**

score数组中存放了3个学生4门功课的成绩，通过调用average函数计算所有学生所有成绩的平均值，通过调用search函数显示第n个学生4门功课的成绩。

思路：需要定义一个二维数组score，每行存储一个学生的4门功课的成绩。有3行，则存储了3个学生的成绩。

![image-20211017210242184](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20211017210242184.png)

- 当编写函数average计算所有学生成绩平均值的时候，可以用一维数组的角度去看待这个score数组，也就是说，“认为”这个数组有12个成绩，直接求和，再计算平均分就行了。

- 当编写函数search显示第n个学生的4门功课的时候，则是用二维数组的角度去看待这个score数组，也就是说，“认为”这个数组有3行，每行4个元素。

  ![image-20211017210833843](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20211017210833843.png)

#### **代码实现**

```c
#include <stdio.h>
void average(float *p,int n){
    float *p_end = NULL;
    float sum = 0,aver;
    p_end = p+n;
    for (;p<p_end;p++){
        sum += (*p);
    }
    aver = sum/n;
    printf("平均成绩为：%5.1f\n",aver);
}

void search(float (*p)[4],int n){       // 可以写成float p[][4]
    int i;
    printf("第%d个学生成绩为:",n);
    for (i=0;i<4;i++){
        printf("%5.1f",*(*(p+n-1)+i));      // 可以替换成p[n][i]
    }
}


int main(){
    float score[3][4]={{65,67,70,60},{80,87,90,81},{90,99,100,98}};
    average(&score[0][0],3*4);
    search(score,2);	//显示第2个学生的成绩
    return 0;
}
```



#### **思考：**

1. 同是给函数传递score二维数组，为什么average函数和search函数传参时采用了不同的方式?

   `average( &score[0][0],12);`
   `search( score, 2); `

2. 为什么average函数除了传递score数组,还要传递整数n?



​	答：1.average以一维数组方式看待数组score，`&score[0][0]`的值是数组第一个元素的具体地址，也是以一维数组的方式看待。

​		2.只传数组的首地址是不够的，我们不光要知道数组的首地址，还需要知道数组的具体长度，让我们的循环得到控制，也就是地址的		具体范围



二维数组作为参数的特点是：**形参数组和实参数组是同一个数组**。只是我们在传参的时候，有两种传参方式。

1. 以一维数组的角度看待二维数组。

   ![image-20211017212756561](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20211017212756561.png)

2. 以二维数组的角度看待数组

   ![image-20211017212913296](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20211017212913296.png)



## 指针函数和函数指针

### **指针函数（返回指针的函数）**

指针函数，就是函数的返回值为指针类型。



#### **指针函数的定义和调用**

- 指针函数的定义

  函数声明：`返回类型 *函数名(参数类型序列);`

  函数定义：`返回类型 *函数名(形式参数序列){`
  				`函数体`
  				`return 返回指针类型量;`
  		`}`

- 指针函数调用

  `char *q;`
  `q=函数名(实际参数列表);`
  q与被调用函数的返回类型一致



#### **案例**

```c
# include <stdio.h>
char *getWord(char c){
    switch (c) {
        case 'A':return "Apple";
        case 'B':return "Banana";
        case 'C':return "Cat";
        case 'D':return "Dog";
        default:return "None";
    }
}


int main(){
    char input;
    printf("please input a character:");
    input = getchar();
    printf("%c\n",input);
    printf("%s\n", getWord(input));
    getchar();
    return 0;
}
```

运行结果：![image-20211018192346211](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20211018192346211.png)

 在这个例子中，输入字母后，返回字母对应的字符串。getWord函数的返回值为字符串的首地址。需要注意的是，这里的“Apple”、“Banana”...都是字符串常量，会存储在专门存储常量的区域。

我们再来看看下面的程序：

```c
#include <stdio.h>
char *getWord(char c){
    char str1[] = "Apple";
    char str2[] = "Banana";
    char str3[] = "Cat";
    char str4[] = "Dog";
    char str5[] = "None";

    switch (c) {
        case 'A':return str1;
        case 'B':return str2;
        case 'C':return str3;
        case 'D':return str4;
        default:return str5;
    }
}


int main(){
    char input;
    printf("please input a character:");
    input = getchar();
    printf("%c\n",input);
    printf("%s\n",getWord(input));
    getchar();
    return 0;
}
```

运行结果：![image-20211018202542895](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20211018202542895.png)

它会给出一个warning：![image-20211018202636033](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20211018202636033.png)

我们运行程序会发现输入字符后并没有得到我们想要的结果，在getWord函数中定义的str1、str2等字符数组是局部变量，它的生存周期只在getWord函数执行的时候，当该函数运行结束后，会**自动释放函数中定义的变量所占用的内存**。给出的warning也提到了，说函数返回的地址是局部变量。

当我们定义指针函数时需要注意：**不要返回局部变量的指针（数组）**。



### **函数指针（指向函数的指针）**

**函数指针**顾名思义就是指向函数起始地址的指针函数指针定义



#### **函数指针的定义**

`函数返回类型(*指针变量名)(函数形参类型列表);`
`int (*fptr)(int,int);`



#### **函数指针的使用**

1. 指针变量名=被指向函数名;
   `fptr=max;`
2. 函数调用：指针变量名(函数调用时的实际参数);
   `int x=fptr(5,8);`



#### **案例**

```c
#include <stdio.h>
int square(int num){
    return num*num;
}


int main(){
    int num;
    int (*fp)(int);
    printf("please input a number:");
    scanf("%d",&num);
    fp = square;
    printf("fp=0x%x, %d\n",fp,(*fp)(num));
    // printf("fp=0x%x, %d\n",fp,fp(num));
    return 0;
}
```

运行结果：![image-20211018204439609](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20211018204439609.png)

我们定义的square函数返回的时int，只有一个参数；所以我们定义的函数指针`int (*fp)(int)`，定义为int是因为square函数的返回值
是int，而fp后面的int是因为square函数需要一个int类型的参数。调用函数时`(*fp)(num)`、`fp(num)`两种方式都可以调用函数。

**函数名等于函数的地址**。通过fp=square;语句使得fp指向函数的入口,因此通过fp指针就能找到函数square的代码存放在哪里，从而调用并执行这段代码。
![image-20211018204405879](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20211018204405879.png)



####　**函数指针的说明**

- 函数指针描述一类函数的共同特征，这些函数有相同的形式参数类型序列，相同的返回类型。

- 函数指针是指针变量，可以指向函数的入口地址,上面函数square的入口地址: 0x401550(每次运行都不一定相同)
- 函数指针与指针函数不同，函数指针是一个指针变量，它可以指向符合定义过程描叙的任何函数;指针函数是一个函数，函数返回值的类型是一个指针。



### **函数指针作为参数进行传递**

这种方式在传参时传递的是一个函数的入口地址。

这种用法在Linux操作系统的源代码中大量使用，能够实现非常灵活的功能。

```c
#include <stdio.h>
int add(int num1,int num2){
    return num1 + num2;
}


int sub(int num1,int num2){
    return num1 - num2;
}


int calculate(int (*fp)(int,int),int num1,int num2){
    return (*fp)(num1,num2);
}


int main(){
    printf("3+5=%d\n", calculate(add,3,5));
    printf("3-5=%d\n", calculate(sub,3,5));
}
```

运行结果：![image-20211018205906620](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20211018205906620.png)

在上面这段程序中，我们把函数名（指向函数的指针，就跟数组名一个道理）和两个int类型的数字传递给calculate，在calculate函数里面调用传入的函数。



### **定义一个函数指针数组**

```c
#include <stdio.h>
void function1(int);
void function2(int);
void function3(int);


int main(){
    void (*f[3])(int) = {function1, function2, function3};
    int choice;
    printf("输入一个数：范围[0-2]");
    scanf("%d",&choice);
    while (choice>=0 && choice<=2){
        (*f[choice])(choice);
        printf("输入一个数：范围[0-2]");
        scanf("%d",&choice);
    }
    printf("程序运行结束！");
    return 0;
}


void function1(int choice){
    printf("输入了%d,运行了function1函数\n",choice);
}


void function2(int choice){
    printf("输入了%d,运行了function2函数\n",choice);
}


void function3(int choice){
    printf("输入了%d,运行了function3函数\n",choice);
}
```

运行结果：![image-20211018211504216](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20211018211504216.png)

在上面这段程序中，` void (*f[3])(int)`的意思是：定义一个**名为f长度为3的数组**，数组的类型为**指向参数为一个int 返回类型为void的函数指针**

![image-20211018212645738](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20211018212645738.png)





## 指针与结构体

在阅览本篇笔记前，请先确保能够熟练使用C语言的结构体语法；如果还不会的话[点击这里](https://www.runoob.com/cprogramming/c-structures.html)学习

### **结构体变量的传参**

#### **结构体变量作为函数的参数**

- 结构体变量可以作为函数的参数在函数之间进行传递。使用结构体变量作为函数参数时,数据的传递仍然是“传值方式“；要求实参与形参的类型必须一致

- 实现方式：函数调用时系统为形参变量开辟一段内存单元(按照结构体变量所需要的存储单元数）以存放从实参传递过去的各结构体变量成员分量的值。

  ![image-20211019193125357](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20211019193125357.png)



#### **返回结构体类型的参数**

结构体类型的数据对象不但能作为函数参数在函数之间传递，还可以作为函数的返回值。当函数的返回值类型是一个结构体类型时，该函数就称为返回结构体类型的函数。

##### **函数定义形式**

```c
struct 标识符 函数名(形式参数表及定义){
    函数的定义和声明部分;
    函数的执行部分;
}
```

#### **案例**

```c
#include <stdio.h>
typedef struct Point{				// 定义结构体
    int x;
    int y;
}Point;


void Display(Point point){			// 使用一个结构体变量作为函数参数
    printf("x is %d\n",point.x);
    printf("y is %d\n",point.y);
}


Point SetPoint(int x,int y){		// 使用结构体作为函数返回值
    Point point;
    point.x = x;
    point.y = y;
    return point;
}


int main(){
    Point point;
    point = SetPoint(2,3);
    Display(point);
    return 0;
}
```

运行结果：![image-20211019194211635](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20211019194211635.png)

在上面这段程序中，定义了一个结构体Point，Point中有x分量和y分量；函数Display接收一个结构体变量，并打印出分量的值；函数SetPoint接收两个int类型变量，在函数体中定义局部Point结构体变量point，将形参x、y的值分别赋值给point的x和y分量，最后返回point变量。

阅读下面的代码，思考运行结果

```c
#include <stdio.h>
typedef struct Point{
    int x;
    int y;
}Point;


void Display(Point point){
    printf("x is %d\n",point.x);
    printf("y is %d\n",point.y);
}


void SetPoint(int x,int y){
    Point point;
    point.x = x;
    point.y = y;
   // return point;
}


int main(){
    Point point;
    SetPoint(2,3);
    Display(point);
    return 0;
}
```

运行结果：![image-20211019195004068](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20211019195004068.png)

原因：我们尽管将2和3传递给SetPoint函数，但是在SetPoint函数中我们仅仅是将2和3赋值给SetPoint的局部变量point，它的生存周期只在SetPoint函数内，在SetPoint函数结束时并没有返回point变量，所以在使用Display函数打印值时会出现意想不到的结果，当结果体变量未赋值时，里面的值是随机的



### **结构体数组的传参**

变量定义：

```c
struct StudentType{
    char no[10];
    char name[10];
    double foreign;
    double spec1;
    double spec2;
    double total;
};
struct StudentType stud[10];
```

![image-20211019195847640](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20211019195847640.png)

#### **结构体数组作为函数参数**

结构体数组可以作为函数的参数在函数间进行传递。使用结构体数组作为函数参数时，实现的是“**传地址值调用**”。即实参数组将全部或部分存储区域提供给形参数组共享。



#### **案例**

采用函数实现结构体数据的输入、计算总分和输出。

- 设函数InputMarks完成输入并保存全体考生的成绩信息,函数AddMarks完成统计并保存每个考生的总分，函数OutputMarks输出每个考生的总分。

```c
#include <stdio.h>

struct StudentType{
    char no[10];
    char name[10];
    double foreign;
    double spec1;
    double spec2;
    double total;
};


void InputMarks(struct StudentType student[],int n);
void AddMarks(struct  StudentType student[],int n);
void OutputMarks(struct StudentType student[],int n);


int main(){
    int n;
    printf("请输入学生人数：");
    scanf("%d",&n);
    struct StudentType student[n];
    InputMarks(student,n);
    AddMarks(student,n);
    printf("各个学生的总成绩为：\n");
    OutputMarks(student,n);
    return 0;
}


void InputMarks(struct StudentType student[],int n){
    for (int i = 0; i < n; i++) {
        printf("请输入第%d考生考号：",i+1);
        scanf("%s",student[i].no);

        printf("请输入第%d个考生姓名：",i+1);
        scanf("%s",student[i].name);

        printf("请输入第%d个考生外语成绩：",i+1);
        scanf("%lf",&student[i].foreign);

        printf("请输入第%d个考生专业课1成绩：",i+1);
        scanf("%lf",&student[i].spec1);

        printf("请输入第%d个考生专业课2成绩：",i+1);
        scanf("%lf",&student[i].spec2);
    }
}


void AddMarks(struct StudentType student[],int n){
    int i;
    for (int i = 0; i < n; i++) {
        student[i].total = student[i].spec1 + student[i].spec2 + student[i].foreign;
    }
}


void OutputMarks(struct StudentType student[],int n){
    for (int i = 0; i < n; i++) {
        printf("%s的总分是%5.1f\n",student[i].name,student[i].total);
    }
}
```

这里需要注意的是，我们在`scanf("%s",student[i].no);`和`scanf("%s",student[i].name);`前面并没有加取地址符”&“，这是因为我们的no和name分量类型都是字符数组，**字符数组变量名实质是一个指针，指向的是数组首地址**，所以不需要加取地址符。



### **指向结构体变量的指针**

把一个结构体变量的起始地址存放在一个指针变量中，那么这个指针变量就指向该结构体变量。

![image-20211019202706451](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20211019202706451.png)

通过指针变量访问结构体变量的成员形式（两种方式等价）：
`(*指针变量).成员名;`
`指针变量名->成员名;`

```c
struct Point{
    int x;
    int y;
}point;
struct Point *P;
p = &point;
```

> 此时p指向结构体类型的point变量，此时，访问结构体中x分量的方式有两种:
> `(*p).x`
> `p->X`
> 推荐使用后者。



#### **案例**

```c
#include <stdio.h>
typedef struct Point{				// 定义结构体
    int x;
    int y;
}Point;


void Display(Point point){			// 使用一个结构体变量作为函数的参数
    printf("x is %d\n",point.x);
    printf("y is %d\n",point.y);
}


void SetPoint(Point *p){			// 使用一个结构体指针作为函数的参数
    p->x = 2;
    p->y = 3;
}


int main(){
    Point point;
    SetPoint(&point);
    Display(point);
    return 0;
}
```

在上面这段程序中，使用SetPoint函数时我们将main函数中point变量的地址作为实参传递，这时SetPoint函数和main函数使用的point变量地址是同一块地址，所以SetPoint函数能够成功修改main函数中point变量的值

> 总结：
> 	子程序中对变量的的修改如果需要传出来，可以采用两种模式:
> 	1.把子程序中的值返回，并在主程序中接收这个返回值。这种方式只能返回一个值。
> 	2.用指针做参数,在子程序中利用指针间接访问主程序中的变量。这种方式能影响主程序中多个变量。



### **指向结构体数组的指针**

有3个学生的信息，放在结构体数组中，要求输出全部学生的信息。

```c
#include <stdio.h>
#define N 3
struct Student {
    int num;
    char name[20];
    char sex;
    int age;
};

struct Student stu[N] = {
    {10101,"Li Lin",'M',18},
    {10102,"ZhangFang",'M',19},
    {10104,"Wang Min",'F',20}
};

int main(){
    struct Student *p = NULL;
    printf(" No.Name\tsex\tage\n");
    for (p = stu; p < stu + N; p++) {
        printf("%5d %-10s %2c %6d\n",
               p->num,p->name,p->sex,p->age);
    }
    return 0;
}
```

运行结果：![image-20211019205326612](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20211019205326612.png)



![image-20211019205345575](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20211019205345575.png)



### **课后练习**

定义存放一个学生信息的结构体类型，学生信息包括:姓名，学号，性别，院系，要求在随意输入5个学生的相关信息后，按照学号从小到大顺序输出这些学生的信息。

输入示例：

zhang3 20149003M信息系
zhang5 20149005F信息系
zhang10 20149010F 管理系
zhang1 20149001 M会计系
zhang9 20149009 M会计系

输出示例:

zhang1 20149001 M会计系
zhang3 20149003 M 信息系
zhang5 20149005 F信息系
zhang9 20149009 M会计系
zhang10 20149010 F管理系

提示:

1. 学生信息采用结构体实现。
2. 采用循环结构比较输入的5个学生，然后按照学号从小到大排序。
3. 将排序后的结果按要求输出。

```c
#include <stdio.h>
#define N 5
struct Student {
    char name[20];
    int num;
    char sex;
    int age;
    char department[20];
};
void inputStudent(struct Student *p, int n);
void sortStudent(struct Student *p, int n);
void swap(struct Student *p, struct Student *q);
void outputStudent(struct Student *p, int n);
int main(void)
{
    struct Student student[N];

    inputStudent(student, N);
    sortStudent(student, N);
    outputStudent(student, N);

    return 0;
}
void inputStudent(struct Student *p, int n)
{
    int i;
    for (i = 0; i < n; i++, p++) {
        printf("请输入第%d个学生姓名：", i + 1);
        scanf("%s", p->name);
        printf("请输入第%d个学生学号：", i + 1);
        scanf("%d", &(p->num));
        getchar();
        printf("请输入第%d个学生性别：", i + 1);
        scanf("%c", &(p->sex));
        printf("请输入第%d个学生院系：", i + 1);
        scanf("%s", p->department);
        getchar();
    }
}
void sortStudent(struct Student *p, int n)
{
    struct Student *end_p, *index_p, *temp_p;

    //指向最后一个学生的指针
    end_p = p + n -1;
    //遍历结构体数组
    for (; p < end_p; p++) {
        index_p = p;
        //找出最小值
        for (temp_p = index_p + 1; temp_p <= end_p; temp_p++) {
            if (temp_p->num < index_p->num) {
                index_p = temp_p;
            }
        }
        if (index_p != p) {
            swap(p, index_p);
        }
    }
}
void swap(struct Student *p, struct Student *q)
{
    struct Student temp;

    temp = *p;
    *p = *q;
    *q = temp;
}
void outputStudent(struct Student *p, int n)
{
    struct Student *end_p;

    end_p = p + n - 1;
    for (; p <= end_p; p++) {
        printf("%s\t%d\t%c\t%s\n", p->name, p->num, p->sex ,p->department);
    }
}
```





##　动态内存分配

### **系统内存分区**

C语言程序编译环境下的系统内存有5个区，每个分别有不同使用者

1. **栈区(Stack)**：编译系统自动分配释放,放函数参数局部变量等
2. **堆区(heap)**：由程序员分配释放管理,一般由malloc,new等内部存储函数使用，如果没收回，程序结束时由操作系统收回。创建堆时，一般在堆的头部用一个字节存放堆的大小；回收堆时，通过查看这个字节的内容，可得知需要释放的多大的内存
3. **全局区或静态区**：存放全局变量和静态变量，程序结束时由系统释放，分为全局初始化区和全局未初始化区
4. **常量区**：存放常量，程序结束时由系统释放
5. **程序代码区**(上面4个区统称数据区)：存放运行或准备运行的程序代码,由系统调度

```c
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

int square(int num){
    int sq = num * num;                     // 子程序参数num和局部变量sq在栈区
    return sq;
}

int a = 0;                                  // 全局变量a在全局初始化区
char *p1;                                   // 全局变量p1在全局未初始化区

int main(){
    int num = 20;                           // 局部变量num、p2、p3在栈区
    char *p2,*p3 = "123456";                //  字符串常量123456\0在常量区
    int a[] = {1,2,3};                      // 数组a(存储了3个整数)在栈区
    static int c = 0;                       // c在全局(静态)初始化区
    p1 = (char *)malloc(10);          // 分配得到的10和20字节的区域就在堆区
    p2 = (char *)malloc(20);          
    strcpy(p1,"123456");            // 123456\0放在常量区，编译器可能会在将它与p3所指向的“123456”优化成一个地方
    printf("square = %d", square(num));     
}
```



### **malloc函数**

其函数原型为：
`void *malloc(unsigned int size);`

功能：分配一块长度为size字节的连续空间，并将该空间的首地址作为函数的返回值。如果函数没有成功执行，返回值为空指针(NULL或0）。由于返回的指针的基类型为void，应该通过显式类型转换后才能存入其他基类型的指针变量中，否则会有警告提示。

例子：

```c
int *p;
p = (int *)malloc(sizeof(int));
```

使用malloc函数需要先导入stdlib.h或者malloc.h头文件





### **free函数**

其函数原型为：
`void free(void *block);`

功能：释放以前分配给指针变量block的动态空间，但指针变量block不会自动变成空指针。

例子：

```c
int *ptr,i=0;
    if((ptr=(int*)malloc(10*sizeof(int)))!=NULL){
        for (i=0;i<10;i++)
            ptr[i]=i*i;
        free(ptr);
    }
```

使用free函数同样需要先导入stdlib.h或者malloc.h头文件

在上面这一段程序中，malloc函数申请了40个字节的内存空间（10*4，一个int4个字节），将指向这块内存的指针转换为int类型后赋值给ptr，使prt以整型看待这40个字节的内存空间，实际上就是包含10个元素的整型数组（数组变量实质上也是一个指针），当ptr赋值成功不等于NULL时，通过数组下标的方式访问元素；循环结束后使用free函数释放掉这40个字节的内存空间。

![image-20211020201107427](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20211020201107427.png)



**在我们使用malloc函数后一定要找到合适的机会释放掉malloc申请的内存**



### **memset函数**

其函数原型为：
`void *memset(void *s, int c, unsigned long n);`

功能：将指针变量 s 所指向的前 n 字节的内存单元用一个“整数” c 替换，注意 c 是 int 型。s 是 void* 型的指针变量，所以它可以为任何类型的数据进行初始化。

例子：

```c
#include <stdio.h>
#include <malloc.h>     // 或者#include<stdlib.h>

int main(){
    int *ip;
    ip = (int *)malloc(10*sizeof(int));
    memset(ip,0,10*sizeof(int));
    int i;
    for (i=0;i<10;i++) {
        printf("0x%-10x",ip[i]);
        if (i==4)
            printf("\n");
    }
    free(ip);
}
```

运行结果：![image-20211020201952936](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20211020201952936.png)

在上面这段程序中，我们申请了40个字节内存空间并将指向这块内存空间的指针强制转换为int类型，使得变量ip以int类型看待这块内存空间，使用memset函数将这一块内存空间初始化为0。在以后我们也可以用memset函数初始化数组。



###　**习题讲解**

设计一个指针函数: `char *catchar(char *,char*)`,完成两个字符串的相加，返回相加后字串地址。

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

char *catstr(char *s1,char *s2){
    char *str,*p;
    int length = strlen(s1) + strlen(s2) + 1; // 计算存放两个字符数组所需空间长度，+1是因为末尾有一个‘\0’结束符
    str = (char *) malloc(length * sizeof(char));   // 分配所需内存空间，转换类型后赋值给str
    memset(str,0,length* sizeof(char));         // 将str所指向的后 length*sizeof(char)个内存空间初始化为0
    p = str;        // 将str的地址赋值给p

    while (*s1){    // 循环结束条件为*s1的值不为‘\0’结束符
        *p++ = *s1++;   // 将s1所指向的内容赋值给p之后在执行++操作
    }

    while (*s2){    // 循环结束条件为*s2的值不为‘\0’结束符
        *p++ = *s2++;    // 将s2所指向的内容赋值给p之后在执行++操作
    }
    *p = '\0';      //最后在末尾添加‘\0’结束符
    return str;     // 返回str指针
}


int main(){
    char s1[] = "123456";   
    char s2[] = "67890";
    char *str = NULL;
    str = catstr(s1,s2);
    printf("%s",str);
    free(str);  // 释放内存空间
    return 0;
}
```

运行结果：![image-20211020203307658](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20211020203307658.png)

在上面这段程序中，在catstr函数中`int length = strlen(s1) + strlen(s2) + 1;`计算存放两个字符数组所需空间长度，+1是因为末尾有一个‘\0’结束符需要占用一个字节；`str = (char *) malloc(length * sizeof(char));`分配所需内存空间，转换类型后赋值给str ；`memset(str,0,length* sizeof(char));`将str所指向的后 length*sizeof(char)个内存空间初始化为0；`*p++ = *s1++; `将s1所指向的内容赋值给p之后在执行++操作，最后返回str指针。之前我们说过**不要返回局部变量指针**，但是在这儿我们使用**malloc函数分配的内存空间是存放在堆区**，除非使用free释放，否则这块内存空间在**整个程序运行时会一直存在**。

上面这段程序有一个弊端，那就是在catstr函数中malloc分配的内存空间并没有在catstr函数中释放掉；如果在实际的开发环境中，你的小组成员负责的内容中有这么一个函数，并把这个函数交给你来调用，而你又不知道或者忘记了需要释放内存，那么就会造成内存泄漏。

我们应该改成下面这样：

```c
#include <stdio.h>
#include <string.h>

char *catstr(char *s1,char *s2){
    char *p;
    p = s1 + strlen(s1);    // 使p指针指向字符数组s1的最后一个元素

    while (*s2){    // 循环结束条件为*s2的值不为’\0‘结束符
        *p++ = *s2++;    // 将s2所指向的内容赋值给p之后在执行++操作
    }
    *p = '\0';      //最后在末尾添加‘\0’结束符
    return s1;     // 返回str指针
}


int main(){
    char s1[30] = "123456";
    char s2[] = "67890";
    char *str = NULL;
    str = catstr(s1,s2);
    printf("%s",str);
    return 0;
}
```





## 链表

### **引例 建立学生信息表**

假设需要建立一个学生信息表，学生人数无法估计，而且学生人数经常发生变化，应该如何实现?

在这种情况下显然不适合使用顺序表，因为顺序表需要事先确定存储容量，并且删除、插入元素都需要大量移动表内元素
而单链表更适合这种来存储这种数据

单链表：线性表的链接存储结构
存储思想：用一组**任意**（不连续、零散分布）的存储单元存放线性表的元素
![image-20211024185416330](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20211024185416330.png)



### **单链表**

单链表存储特点：

1. 逻辑次序和物理次序不一定相同。
2. 元素之间的逻辑关系用指针表示。

举例：

- (a1,a2,a3,a4)的存储示意图

  ![image-20211024185901241](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20211024185901241.png)

单链表是由若干结点构成的；单链表的结点只有一个指针域。

单链表的结点结构：
![image-20211024190108844](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20211024190108844.png)

data:存放数据元素
next:存储指向后继结点的地址

如上图存储示意图中：第一个元素a1的地址为0208，其中有数据域存放数据a1，指针域存放指向下一个结点的地址0200，而0200又是第二个元素的地址

### **单链表的结点结构**

```c
typedef struct node {
    DataType data;		// 数据域
    struct node *next;	// 指针域
}Node,*Link;
```

注意：上面代码中的DataType是**具体的数据类型**，如int、float、double等，或是其他结构体；实际使用时根据具体情况修改，**不要傻乎乎的在实际代码中也写上DataType**。

`Node`和`*Link`都可以用来定义结构体变量，只不过使用`*LINK`定义变量时就不用再前面加“*”，因为这里已经有了一个“\*”,用`*Link`定义的变量都为指针变量。



#### **如何访问结构体中的数据元素？**

1. `(*p).data`
2. `p->data`



#### **如何访问结构体中的指针域？**

`p->next`



#### **什么是存储结构？**

重点在数据元素之间的逻辑关系的表示，所以，将实际存储地址抽象。

链表的实际存储结构如下图所示：
![image-20211024192327312](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20211024192327312.png)
它在内存中是离散的、不连续的，为了方便理解我们一般将它画出下面这样
![image-20211024192444393](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20211024192444393.png)

用一个head指针指向链表的第一个结点

头指针：指向第一个结点的地址。
尾标志：终端结点的指针域为空。

空表：head=NULL;

头结点：为了方便编程，我们在单链表的第一个元素结点之前附设一个类型相同的结点，以便空表和非空表处理统一。头结点的数据域是没有用的，我们只使用它的指针域，指向链表的第一个结点。
![image-20211024192826573](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20211024192826573.png)

空表的头结点next域为NULL；非空表的头结点next域指向第一个结点



### **单链表的遍历操作**

```c
void displayNode(Link head){
    Link p = head->next;
    while (p != NULL){
        printf("%d",p->data);
        p = p->next;
    }
}
```

在上面的代码中，传入一个头结点的指针，指针p指向链表的第一个结点，也就是head->next；而在链表中最后一个结点的next域是为NULL的，所以我们在循环中打印结点的数据域后将p指针移动到下一个结点，也就是p->next。当p=NULL时循环结束。

问：p++能否完成指针后移？

答：不能，我们在使用数组或顺序表时可以使用p++访问下一个元素，那是因为数组在内存中的存储时**连续的**，而链表在内存中的存储时**离散的**，p++后p指针并不能正确的指向后继结点的位置。



### **求单链表的元素个数**

```c
int getLength(Link head){
    int cnt = 0;    // 定义计数器，初值为0
    Link p = head->next;    // 定义指向链表第一个结点的指针p

    while (p != NULL){
        p = p->next;
        cnt ++;
    }
    return cnt;
}
```

每遍历一个结点时，都使得cnt加1，当p等于NULL时遍历结束，返回cnt的值。



### **单链表的查找操作**

```C
int queryNode(Link head,int x){
    Link p = head->next;

    while (p != NULL){
        if (p->data == x){
            printf("%d",p->data);   // 找到则打印值并返回1
            return 1;
        }
        p = p->next;
    }
    return -1;  // 如果循环结束，说明没找到，返回-1
}
```

在遍历链表的过程中将要查找的值与链表中每一个结点的数据域作比较，如果相等则找到，返回1，遍历结束就说明没有找到，返回-1

因为在C语言C89标准中是没有布尔类型的，所以我们使用1和-1来代替，如果要使用的话需要在C99标准中引用头文件stdbool.h，或者自己宏定义一下



### **单链表的插入操作**

 ![image-20211024195952662](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20211024195952662.png)

插入一个结点时，我们要让指针p移动到合适的位置，使得 a~i-1~的next域指向新创建的结点node，node的next域指向a~i~。

算法描述：

```c
让p移动到正确的位置
node = (Link)malloc(sizeof(Node));
node->next = p->next;
p->next = node;
```

当**单链表带头结点时**，表头、表中、表尾三种情况的操作语句一致。

完整代码：

```c
bool insertNode(Link head,int x,int i){
    Link p = head;      // 工作指针p指向头结点
    int cnt = 0;
    while (p != NULL && cnt < i-1){     // 查找i-1个结点
        p = p->next;
        cnt ++;
    }
    if (p == NULL){
        return false;       // 没有找到x-1个结点
    } else{
        Link node = (Link) malloc(sizeof(Node));    //申请一个结点node
        node->data = x;
        node->next = p->next;       // 结点node插入结点p后面
        p->next = node;
        return true;
    }
}
```

在第i个结点之前插入结点，数据域为x。循环的结束条件为cnt < i-1 并且 p!=NULL；当p=NULL时该链表为空，返回false，当cnt==i-1时退出循环，p指针正好指向第i个结点的前一个结点，执行插入操作。在这个过程中比较复杂的是a~i-1~结点和a~i~结点之间的断链操作，这个过程不理解的小伙伴可以用笔跟着上面的代码“人工 智能”的把这个过程画出来理解一下，这个东西用文字不好描述，博主这里就不描述了

博主在这里使用了布尔型，小伙伴们使用布尔型的话需要在C99标准下引入头文件stdbool.h



### **单链表的创建--头插法**

伪代码：

- 创建一个头结点head
- 将head的next域赋为NULL
- 创建一个新结点node
- 输入node data域的值x
- 把x赋值给node->data
- 把head的next域赋值给node的next域
- 把node赋值给head的next域

算法描述：

```c
Link head;
head->next = NULL;
node = (Link)malloc(sizeof(Node));
int x; 
scanf("%d",&x);
node->data = x;
node->next = head->next;
head->next = node;
```

完整代码：

```c
Link headList(){
    Link head = (Link) malloc(sizeof(Node));        // 创建头结点
    head->next = NULL;		// 头结点的next域赋为NULL
    int x;
    Link node;
    scanf("%d",&x);

    while (x != -1){
        node = (Link) malloc(sizeof(Node));		// 申请新的结点
        node->data = x;		// 给新结点的data域赋值
        node->next = head->next;
        head->next = node;
        scanf("%d",&x);
    }
    return head;
}
```

头插法的特点是**输入的顺序和链表的顺序是反过来的**。



### **单链表的创建--尾插法**

伪代码：

- 创建头结点head
- head的next赋为NULL
- 创建尾结点rear指向head
- 输入值x
- 创建新结点node
- x赋给node的data域
- rear的next域指向node
- rear指向node

算法描述：

```c
Link head;
head->next = NULL;
Link rear = head;
int x;
scanf("%d",&x);
Link node;
node->data = x;
r->next = node;
r=node;
```

完整代码：

```c
Link tailList(){
    Link head = (Link) malloc(sizeof(Node));    // 生成头结点
    head->next = NULL;
    Link node,rear = head;      // 尾指针初始化
    int x;
    scanf("%d",&x);
    while (x != -1){
        node = (Link) malloc(sizeof(Node));     // 申请新结点
        node->data = x;         // 新结点data域赋值
        rear->next = node;      // 尾指针的next域指向新结点，这时的尾指针指向的是目前最后一个结点
        rear = node;            // 刷新尾指针 指向新结点
        scanf("%d",&x);
    }
    rear->next = NULL;
    return head;
}
```





### **单链表结点的删除**

 ![image-20211024213252527](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20211024213252527.png)

我们需要一个前驱指针q和一个指向删除结点的指针p，使得q在p的前一个结点,然后`q->next=p->next;free(p)`就行了

但是问题来了，删除很简单，但如何能让指针移动到合适的位置，并且保证p指向要删除的结点，q则指向p的前驱结点?

我们在初始化时这样：
`q=head;`
`p=head->next;`

![image-20211024213735157](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20211024213735157.png)

这样q、p就保持了一前一后的关系

当我p所指向的结点不是我们想要删除的结点时,移动指针一次!

`q=p;`
`p=p->next;`

![image-20211024214110812](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20211024214110812.png)



当p所指的结点是我们想要删除的结点时

`free(p)`



当遍历完数组后都没有找到我们想要删除的元素时

![image-20211024214215538](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20211024214215538.png)

此时我们退出循环，返回false

如果这个链表是空的

![image-20211024214440399](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20211024214440399.png)

提前返回false

完整代码：

```c
bool deleteNode(Link head,int x){
    if (head == NULL || head->next == NULL){
        return false;
    }
    Link p = head->next;
    Link q = head;
    while (p != NULL){
        if (p->data == x){
            q->next = p->next;
            free(p);
            return true;
        } else{
            q = p;
            p = p->next;
        }
    }
    return false;
}
```



###　**单链表的释放**

```c
void clearLink(Link head){
    Link p;
    while (head != NULL){
        p = head;
        head = head->next;
        free(p);
    }
}
```



### **循环链表**

![image-20211024220217258](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20211024220217258.png)

链表中最后一个结点的next域指向head结点

将单链表的首尾相接，将终端结点的指针域由空指针改为指向头结点，构成**单循环链表**，简称**循环链表**。

空循环链表![image-20211024220357806](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20211024220357806.png)



遍历循环链表的退出条件：`p!=head;`或`p->next!=head;`

循环链表的基本操作跟单链表差不多，这里博主就不写了



### **双向链表**

![image-20211024220713347](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20211024220713347.png)

双向链表：在单链表的每个结点中再设置一个指向其前驱结点的指针域。

结点结构：![image-20211024220842261](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20211024220842261.png)

- data：数据域，存储数据元素;
- prior：指针域，存储该结点的前趋结点地址;
- next：指针域,存储该结点的后继结点地址。

双向链表一般不怎么用，维护起来也比较麻烦，所以双向链表的基本操作博主也不写了。  



## 顺序栈

###　**栈的概念**

栈（stack）是一种只允许在一端进行插入和删除的线性表表，它是一种**操作受限**的线性表。在表中只允许进行插入和删除的一段称为**栈顶（top）**，另一端称为**栈底（bottom）**。

具体的示意图我就不贴了，大家看看底部第视频就很容易理解。



### **顺序栈的存储结构**

```c
#define  MAXSIZE 50

typedef struct {
    int data[MAXSIZE];
    int top;
}stack,*stack_ptr;
```

通常0下标端设为栈底，这样空栈时栈顶指针top=-1；入栈时，栈顶指针加1，既s->top++；出栈时栈顶指针减1，既s->top--



### **置栈空**

首先建立栈空间，然后初始化栈顶指针。

```c
stack_ptr init_stack(){
    stack_ptr s = (stack_ptr)malloc(sizeof(stack));
    s->top = -1;
    return s;
}
```



### **判栈空**

```c
bool empty_stack(stack_ptr s){
    if (s->top == -1) return true;
    else return false;
}
```

注意：使用布尔型需要在C99标准下导入stdbool.h头文件



### **入栈**

```c
bool push_stack(stack_ptr s,int x){
    if (s->top == MAXSIZE -1) {
        return false;      // 判断栈满，不能入栈
    }
    else{
        s->top++;
        s->data[s->top] = x;
        return true;
    }
}
```



### **出栈**

```c
bool pop_stack(stack_ptr s,int *x){
    if (empty_stack(s)){
        return false;       // 栈空不能出栈
    }else{
        *x = s->data[s->top];
        s->top--;
        return true;
    }
}
```



### **取栈顶元素**

```c
int top_stack(stack_ptr s){
    if (empty_stack(s)){
        return 0;       // 栈空不能取栈顶元素  
    }
    else{
        return (s->data[s->top]);   
    }
}
```



注意一下几点：

1. 对于顺序栈，入栈时，首先判断栈是否满了，栈满的条件为：`s->top==MAXSIZE-1`，栈满时不能入栈；否则出现空间溢出，引起错误，这种现象称为上溢。
2. 出栈和读栈顶操作，先判断栈是否为空，为空时不能操作，否则产生错误。
3. 取栈顶元素与出栈的不同之处在于出栈操作改变栈顶指针top的位置（栈顶指针下移一个位置），而取栈顶元素操作只是读出栈顶元素的值，栈顶指针top不改变。





## 双端栈

在计算机系统软件中，各种高级语言的编译系统都离不开栈的使用。常常一个程序中要用到多个栈，若采用顺序栈，会因为所需的栈空间大小难以准确估计，产生有的栈溢出、有的栈空间还很空闲的情况。为了不发生上溢错误，就必须给每个栈预先分配一个足够大的存储空间，但实际中很难准确地估计。另一方面，若每个栈都预分配过大的存储空间，势必会造成系统空间紧张。若让多个栈共用一个足够大的连续存储空间，则可利用栈的动态特性使它们的存储空间互补，这就是栈的**共享邻接空间**。

栈的共享中最常见的是两栈的共享。假设两个栈共享一维数组stack(MAXNUM)，则可以利用栈的“**栈底位置不变，栈顶位置动态变化**”的特性，两个栈底分别为**-1和MAXNUM**，而它们的栈顶都往中间方向延伸。因此，只要整个数组stack[MAXNUM]未被占满，无论哪个栈的人栈都不会发生上溢。



### **双端栈的存储结构**

```c
typedef struct{
    int stack[MAXNUM];		// Elemtype可以为任意类型
    int lefttop;				// 左栈栈顶指示器
    int righttop;				// 右栈栈顶指示器
}dupsqstack,*dupsqstack_ptr;
```

stack可以根据具体使用情况修改为其他类型

![image-20211106171308981](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20211106171308981.png)

两个栈共享邻接空间的示意图如上图所示。左栈入栈时，栈顶指针加1，右栈入栈时，栈顶指针减1。由于两个栈顶均可向中间伸展，互补余缺，因此使得每个栈的最大空间均大于 m/2。

为了识别左右栈，必须另外设定标志：

```c
char status;
status = 'L';	// 左栈
status = 'R';	// 右栈
```

在进行栈操作时，需要指定栈号：status='L'为左栈，status='R'为右栈；判断栈满的条件为：s->lefttop+1==s->righttop;



### **双端栈的初始化操作**

```c
dupsqstack_ptr init_dupstack(){
    dupsqstack_ptr dupstack = (dupsqstack_ptr)malloc(sizeof(dupstack));     // 申请内存空间
    if (dupstack == NULL){  // 如果内存空间申请失败 返回NULL
        return NULL;
    }
    dupstack->lefttop = -1; // 初始化双端栈
    dupstack->righttop = MAXNUM;   
    return dupstack;    // 返回双端栈指针
}
```

初始化双端栈后返回双端栈指针



### **入栈操作**

```c
bool push_dupstack(dupsqstack_ptr dupstack,char status,int x){
    if (dupstack->lefttop + 1 == dupstack->righttop) return false;  // 判断栈满
    if (status == 'L'){
        dupstack->stack[++dupstack->lefttop] = x;   // 左栈进栈
    } else if(status == 'R'){
        dupstack->stack[--dupstack->righttop] = x;  // 右栈进栈
    } else{
        printf("参数错误！");
        return false;       // 打印错误信息 返回false
    }
    return true;
}
```





### **出栈操作**

```c
int pop_dupstack(dupsqstack_ptr dupstack,char status){
    if (status == 'L'){
        if (dupstack->lefttop < 0) return -1;     // 左栈为空
        else return (dupstack->stack[dupstack->lefttop--]);     // 左栈出栈
    } else if (status == 'R'){
        if (dupstack->righttop > MAXNUM -1) return -1;    // 右栈为空
        else return (dupstack->stack[dupstack->righttop++]);    // 右栈出栈
    } else{
        printf("参数错误！");
        return -1;    //参数错误
    }
}
```



## 链栈

要避免栈的上溢，更好的办法是使用链式存储结构，让多个栈共享所有可用存储空间。所以，栈也可以采用链式存储结构表示，这种结构的栈简称为**链栈**。在一个链栈中，栈底就是链表的最后一个结点，而栈顶总是链表的第一个结点。因此，新入栈的元素即为链表新的第一个结点，只要系统还有存储空间，就不会有栈满的情况发生。

![image-20211107210103753](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20211107210103753.png)

一个链栈可由栈顶指针top唯一确定，上图给出了链栈中数据元素与栈顶指针top的关系。采用**带头结点的单链表**实现栈。因为**栈的插入和删除操作仅限制在表头位置进行**，所以链表的表头指针top就作为栈顶指针，top始终指向当前栈顶元素前面的头结点，即top->next为栈顶元素，当top->next==NULL， 则代表栈空。



### **链栈的存储结构**

```c
typedef struct stacknode{
    int data;
    struct stacknode *next;
}link_stack,*link_stack_ptr;
```

可以根据使用情况将data换成其他数据类型。



### **栈的初始化**

```c
link_stack_ptr init_link_stak(){
    link_stack_ptr top = (link_stack_ptr) malloc(sizeof(link_stack));   // 申请栈顶结点top 当内存空间不够是malloc会返回NULL
    if (top == NULL) return NULL;   // top==NULL既初始化失败 返回NULL
    top->next = NULL;   
    return top; // 返回栈顶结点
}
```

每次使用栈时需要先调用这个函数返回一个栈顶结点



### **入栈操作**

```c
bool push_link_stack(link_stack_ptr top,int x){
    link_stack_ptr s = (link_stack_ptr) malloc(sizeof (link_stack));
    if (s == NULL) return false;    // 当内存空间不够时使用malloc分配内存空间会返回NULL 代表分配失败返回false
    s->data = x;
    s->next = top->next;
    top->next = s;
    return true;    // 入栈成功返回true
}
```

这里利用了链表的头插法特性，算法思想差不多。
你说啥？不认识链表？[点击这里][https://strongforu.top/archives/326]认识一下



### **出栈操作**

```c
int pop_link_stack(link_stack_ptr top){
    link_stack_ptr s = NULL;
    int x;
    if (top->next == NULL) return -1;    // 栈顶指针的next域为NULL时 栈为空栈，返回-1
    s = top->next;
    x = s->data;
    top->next = s->next;
    free(s);
    return x;
}
```



### **多个链栈的操作**

在程序中我们经常使用多个栈，为了方便我们的操作和管理，我们可以将多个单链栈的栈顶指针放在一个一维数组里面。就像这样
![image-20211107220013011](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20211107220013011.png)

我们定义一个一维数组top[M]
`*link_stack_ptr top[M];` 其中，top[0]，top[1]，…，top[i]，…，top[M-1]指向M个不同的链栈，**分别是M个链栈的栈顶指针**，操作时只需确定链栈号i，然后以top[i]为枝顶指针进行栈操作，就可实现各种操作。



#### **栈的初始化**

```c
void init_mul_linkstk(link_stack_ptr top[],int n){
    /*n为数组长度*/
    link_stack_ptr s = NULL;

    for (int i=0;i<n;i++){
        s = (link_stack_ptr) malloc(sizeof(link_stack));
        s->next = NULL;
        top[i] = s;
    }
}
```

需要注意的是：一定要先**在主函数里**定义一个链栈类型的数组。



#### **入栈**

```c
bool push_mul_linkstk(link_stack_ptr top[],int i,int x){
    /*将元素x压入链栈top[i]中*/
    link_stack_ptr s = (link_stack_ptr) malloc(sizeof(link_stack));
    if (s == NULL) return false;    // 申请栈顶结点top 当内存空间不够是malloc会返回NULL
    s->data = x;
    s->next = top[i]->next;
    top[i]->next = s;
    return true;
}
```



#### **出栈**

```c
int pop_mul_linkstk(link_stack_ptr top[],int i){
    link_stack_ptr s = NULL;
    int x;
    if (top[i]->next == NULL) return -1;    // 栈顶指针的next域为NULL时 栈为空栈，返回-1
    s = top[i]->next;
    x = s->data;
    top[i]->next = s->next;
    free(s);
    return x;
}
```



> 这些函数里面还有一点点缺陷：在栈还未初始化前就进行出栈入栈操作。
>
> 具体怎么解决留给小伙伴们自己思考。





## 队列（循环队列）

### **队列模型**

- **队列**：只允许在一端进行插入操作，而另一端进行删除操作的线性表。
- 允许插入（也称入队、进队）的一端称为队尾，允许删除(也称出队）的一端称为队头。
- **空队列**：不含任何数据元素的队列。

![image-20211110153207330](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20211110153207330.png)

![队列基操](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/%E9%98%9F%E5%88%97%E5%9F%BA%E6%93%8D.gif)

特性：**先进先出**



### **队列的顺序存储**

#### **如何利用数组实现队列的顺序存储?**

例：a~1~ a~2~ a~3~ a~4~依次入队

![数组实现队列入队](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/%E6%95%B0%E7%BB%84%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97%E5%85%A5%E9%98%9F.gif)

入队操作时间性能为O(1)



例：a~1~ a~2~依次出队

![数组队列出队](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/%E6%95%B0%E7%BB%84%E9%98%9F%E5%88%97%E5%87%BA%E9%98%9F.gif)

我们可以看到每当一个元素出队之后，后面的元素就会依次往前移动，所以出队操作时间性能为O(n)



#### **如何改进出队的时间性能?**

放宽队列的所有元素必须存储在数组的前n个单元这一条件,只要求队列的元素存储在数组中连续的位置。设置**队头、队尾两个指针**

![入队改良](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/%E5%85%A5%E9%98%9F%E6%94%B9%E8%89%AF.gif)

我们用下标的方式来表示队首和队尾，一开始front和rear在-1这个位置，front表示对头、rear表示队尾，入队前将rear+1，数据存储在rear的位置

约定：队头指针front指向队头元素的前一个位置，队尾指针rear指向队尾元素。
特点：从队尾依次入队，从队头依次出队。

![队列改良出队](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/%E9%98%9F%E5%88%97%E6%94%B9%E8%89%AF%E5%87%BA%E9%98%9F.gif)

出队时，front指向要出队元素的前一个位置，每次出队时，front+1，再读取front指向的元素；front的下一个元素就是队列队头的位置



**假溢出**：当元素被插入到数组中下标最大的位置上之后,队列的空间就用尽了，尽管此时数组的低端还有空闲空间，这种现象叫做假溢出。

![image-20211110164551315](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20211110164551315.png)



### **循环队列**

如何解决假溢出问题呢？

我们采用循环队列，将存储队列的数组头尾相连
![image-20211110164909606](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20211110164909606.png)

头尾相连的循环表的构造方法可以利用数学上的求模运算。

入队时的队尾指针加1修改为：rear=(rear+1)%MAXSIZE

出队时对头指针加1操作修改为：front=(front+1)%MAXSIZE



为了方便判断队空和队满的条件，我们用队列存储数据时牺牲一个存储单元
![image-20211110165912228](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20211110165912228.png)

这时队满的条件为：(rear+1)%MAXSIZE==front
队空的条件为：front\==rear



### **代码实现**

#### **存储结构**

```c
#define MAXSIZE 10
typedef struct {
    int data[MAXSIZE];
    int front,rear;
}CSeQueue,*CSeQueue_ptr;
```



#### **初始化队列**

```c
CSeQueue_ptr initSeQueue(){
    CSeQueue_ptr q = malloc(sizeof(CSeQueue));
    q->front = q->rear = MAXSIZE-1;
    return q;
}
```



#### **入队**

```c
bool InSeQueue(CSeQueue_ptr q, int x){
    if ((q->rear + 1) % MAXSIZE == q->front) {
        printf("队满\n");
        return false;   // 队满不能入队
    } else {
        q->rear = (q->rear + 1) % MAXSIZE;
        q->data[q->rear] = x;
        return true;
    }
}
```



#### **出队**

```c
bool outSeQueue(CSeQueue_ptr q,int *x){
    if (q->front == q->rear){
        printf("队空\n");
        return false;   // 队空不能出队
    } else {
        q->front = (q->front + 1) % MAXSIZE;
        *x = q->data[q->front];
        return true;
    }
}
```



#### **判队空**

```c
bool EmptyQueue(CSeQueue_ptr q){
    if (q->rear == q->front) return true;
    else return false;
}
```





## 链队列

在程序设计语言中不可能动态分配一维数组来实现循环队列。如果要使用循环队列，则必须为它分配最大长度的存储空间，这样必然会造成内存空间的浪费。更好的方法就是使用**链式队列**，用单链表来实现先链式队列。

为了方便，我们采用带头结点的单链表，并设置一个队头**指针front**和一个**队尾指针rear**。front始终指向头结点，尾指针指向当前最后一个元素结点。
![image-20211111222317681](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20211111222317681.png)

### **存储结构**

```c
typedef struct node{
    int data;
    struct node *next;
}q_node,*q_node_ptr;	// 链队结点类型

typedef struct {
    q_node_ptr front;
    q_node_ptr rear;
}link_queue,*link_queue_ptr;	// 将头尾指针封装到一起
```

按照上面的存储结构以及变量名来看的话，实际结构差不多是下面这张图的样子
![image-20211111224343246](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20211111224343246.png)

空队列是这样子：![image-20211111224354454](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20211111224354454.png)

链队列的插入删除操作和链表的插入删除操作是类似的，但是要限定**入队操作只能在表尾进行，出队操作只能在表头进行**。
![链队列入队](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/%E9%93%BE%E9%98%9F%E5%88%97%E5%85%A5%E9%98%9F.gif)
![链队列出队](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/%E9%93%BE%E9%98%9F%E5%88%97%E5%87%BA%E9%98%9F.gif)

**<font color='red'>另外一定要注意仅有一个元素结点的出队操作</font>**，在释放该节点的内存空间后要对尾指针进行修改。



### **创建一个带头结点的空队列**

```c
link_queue_ptr init_link_queue() {
    /*返回一个带指向带头结点的队列指针*/
    link_queue_ptr q = (link_queue_ptr)malloc(sizeof(link_queue));
    q_node_ptr node = (q_node_ptr) malloc(sizeof(q_node));
    q->rear = q->front = node;
    return q;
}
```



### **入队**

```c
bool in_link_queue(link_queue_ptr q,int x) {
    q_node_ptr node = (q_node_ptr) malloc(sizeof(q_node));
    if (node == NULL) return false;     // 不能分配新节点返回false
    node->data = x;
    node->next = NULL;
    q->rear->next = node;
    q->rear = node;
    return true;
}
```



### **判队空**

```c
bool is_empty_link_queue(link_queue_ptr q) {
    if (q->front == q->rear) return true;
    else return false;
}
```



### **出队**

```c
bool out_link_queue(link_queue_ptr q,int *x) {
    if (is_empty_link_queue(q)) return false;	// 队空返回false
    q_node_ptr node = (q_node_ptr) malloc(sizeof(q_node));
    node = q->front->next;
    *x = node->data;
    q->front->next = node->next;
    free(node);
    if (q->front->next == NULL) q->rear = q-> front;  // 当队列只剩一个结点时出队 处理尾指针
    return true;
}
```



main函数调用：

```c
//
// Created by EImago on 2021/11/10.
//

#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>

typedef struct node{
    int data;
    struct node *next;
}q_node,*q_node_ptr;

typedef struct {
    q_node_ptr front;
    q_node_ptr rear;
}link_queue,*link_queue_ptr;

link_queue_ptr init_link_queue() {
    /*返回一个带指向带头结点的队列指针*/
    link_queue_ptr q = (link_queue_ptr)malloc(sizeof(link_queue));
    q_node_ptr node = (q_node_ptr) malloc(sizeof(q_node));
    q->rear = q->front = node;
    return q;
}

bool in_link_queue(link_queue_ptr q,int x) {
    q_node_ptr node = (q_node_ptr) malloc(sizeof(q_node));
    if (node == NULL) return false;     // 不能分配新节点返回false
    node->data = x;
    node->next = NULL;
    q->rear->next = node;
    q->rear = node;
    return true;
}

bool is_empty_link_queue(link_queue_ptr q) {
    if (q->front == q->rear) return true;
    else return false;
}

bool out_link_queue(link_queue_ptr q,int *x) {
    if (is_empty_link_queue(q)) return false;	// 队空返回false
    q_node_ptr node = (q_node_ptr) malloc(sizeof(q_node));
    node = q->front->next;
    *x = node->data;
    q->front->next = node->next;
    free(node);
    if (q->front->next == NULL) q->rear = q-> front;  
    return true;
}

int main(){
    link_queue_ptr queue = init_link_queue();
    in_link_queue(queue,10);
    in_link_queue(queue,11);
    in_link_queue(queue,12);
    int x;
    out_link_queue(queue,&x);
    out_link_queue(queue,&x);
    in_link_queue(queue,20);
    out_link_queue(queue,&x);
    in_link_queue(queue,10);
    in_link_queue(queue,11);
}
```

小伙伴们可以在主函数中入队出队的语句处打上断点debug看一下具体过程。



## 串

### **串的逻辑结构**

- **子串**:串中任意个连续的字符组成的子序列。
- **主串**:包含子串的串。
- **子串的位置**:子串的第一个字符在主串中的序号。



#### **案例**

S="ab12cd"	T1="ab12"	T2="ab13"
主串为S，T1在主串中能够匹配成功，位置为0；T2在S中不能匹配成功，不是子串。



### **串的存储结构**

如何表示串的长度？

1. 用一个变量来表示串的实际长度。
   ![image-20211112181201613](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20211112181201613.png)

2. 在串尾存储一个不会在串中出现的特殊字符作为串的终结符，表示串的结尾。
   ![image-20211112181310059](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20211112181310059.png)
   在C、C++、java中都是采用这种方法

3. 用数组的0号单元存放串的长度，从1号单元开始存放串值。

   ![image-20211112181411426](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20211112181411426.png)



### **模式匹配**

**模式匹配**：给定主串S="s1 s2 … sn"和模式T="t1 t2 ... tn"，在S中寻找T的过程称为模式匹配。如果匹配成功，返回T在S中的位置；如果匹配失败，返回-1。

> 模式匹配问题有什么特点?
>
> 1. 算法的一次执行时间不容忽视：问题规模通常很大，常常需要在大量信息中进行匹配；
> 2. 算法改进所取得的积累效益不容忽视：模式匹配操作经常被调用，执行频率高。



### **BF算法**

BF算法，即暴力(Brute Force)算法。

**基本思想**：从主串S的第一个字符开始和模式T的第一个字符进行比较，若相等，则继续比较两者的后续字符;否则，从主串S的第二个字符开始和模式T的第一个字符进行比较，重复上述过程，直到T中的字符全部比较完毕，则说明本趟匹配成功；或S中字符全部比较完，则说明匹配失败。
![BF算法](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/BF%E7%AE%97%E6%B3%95.gif)

将text[i]和pattern[j]的元素依次比较，若相等则i、j同时后移一个单位；若不相等i、j回溯，`i=i-j+1;j=0`。当所有字符匹配完毕后返回位置`i-j;`



#### **BF算法伪代码**

1. 在串S和串T中设比较的起始下标i和j；
2. 循环直到S或T的所有字符均未比较完
   1. 如果S[i]==T[j]，继续比较S和T的下一个字符；
   2. 否则，将i和j回溯，准备下一趟比较;
3. 如果T中所有字符均比较完，则匹配成功，返回匹配的起始比较下标;否则，匹配失败，返回-1；



#### **代码实现**

```c
int BF(char S[],char T[]){
    int i = 0;
    int j = 0;
    while (S[i] != '\0' && T[j] != '\0'){
        if (S[i] == T[j]){
            i++;
            j++;
        }
        else {
            i = i - j + 1;
            j = 0;
        }
    }
    if (T[j] == '\0') return (i - j);
    else return -1;
}
```



main函数调用：

```c
//
// Created by EImago on 2021/11/12.
//

#include <stdio.h>

int BF(char S[],char T[]){
    int i = 0;
    int j = 0;
    while (S[i] != '\0' && T[j] != '\0'){
        if (S[i] == T[j]){
            i++;
            j++;
        }
        else {
            i = i - j + 1;
            j = 0;
        }
    }
    if (T[j] == '\0') return (i - j);
    else return -1;
}

int main(){
    char s1[] = "abcdefg";
    char t1[] = "def";
    printf("%d\n", BF(s1,t1));
    char s2[] = "abcdefg";
    char t2[] = "deg";
    printf("%d\n", BF(s2,t2));
}
```

运行结果：![image-20211112190833473](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20211112190833473.png)

 

## KMP算法

在[BF算法][https://www.strongforu.top/archives/374]中每当匹配失败时，i、j都将同时回溯，没有利用已经部分匹配的结果；这使得BF算法的时间性能非常低。

如何在匹配不成功时主串不回溯？这需要模式串滑动一定距离，这就有了KMP算法



我们来看看KMP算法的基本思想

![image-20211113184716592](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20211113184716592.png)
主串S、子串T，从起点开始逐一比较，直到遇到失配的情况。



![image-20211113184955847](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20211113184955847.png)
这时候我们可以发现，子串T中前缀和后缀相等；**主串S中黄色框内的ab**和**子串S中的后缀ab**相等，则必然**主串S中黄色框内的ab**和**子串前缀ab**相等



![image-20211113185509356](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20211113185509356.png)
这个时候j则回溯到上图中的位置



![image-20211113185721473](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20211113185721473.png)
第2趟比较时，子串T与相较于主串S移动位数位4，i、j继续往后比较，这样就减少了大量回溯，这就是KMP算法。

KMP算法忽略尽量多的无用匹配，而同时保证不丢失应该做匹配测试的所有可能位置。



可能一些小伙伴对KMP算法一下子移动这么多位不大放心，下面让我们来看一看。
![image-20211113190914601](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20211113190914601.png)

s[1]=t[1]，但是t[0]≠t[1]所以t[0]不等于s[1]，由此可见第二趟比较中，s[1]与t[0]的比较是不需要的，同理可得，主串S中的前4个单元都不需要与子串T进行比较，所以可以将T向后滑动4个单元。
![image-20211113191621032](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20211113191621032.png)

前面的示意图中，只有第5趟是必须的。
结论：指向串S的**变量i可以不回溯**，模式串T向右滑动到的新比较起点k，并且**k仅与模式串T有关**!



### next数组

我们把KMP算法中j回溯的值，放在数组next中，而KMP算法的重点就在于如何求出next数组。

计算next[j]的方法：

- 当j=0时，next[jl=-1;
  next[j]=-1表示不进行字符比较
- 当j>0时，next[j]的值为：模式串的位置从0到j-1构成的串中所出现的**首尾相同的子串的最大长度**。
- 当无首尾相同的子串时next[j]的值为0。
  next[j]=0表示从模式串头部开始进行字符比较



下面我们来看看具体求解方法：

![image-20211113192456036](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20211113192456036.png)
当next[j]=-1时，不进行比较。
next[j]=0，意味着当前字符的真前缀子串和真后缀子串相等的长度为0。

![image-20211113193945599](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20211113193945599.png) ![image-20211113194113529](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20211113194113529.png)



求出next数组后，我们把它带入KMP算法计算

![image-20211113194436761](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20211113194436761.png)

![image-20211113194806900](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20211113194806900.png)

![image-20211113194939707](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20211113194939707.png)



### KMP代码描述

1. 在串S和串T中分别设比较的起始下标i和j;
2. 循环直到S或T的所有字符均未比较完
   1. 如果S[i]=T[j]，继续比较S和T的下一个字符;
   2. 否则**将j向右滑动到next[li]位置，即j=next[ij];**
   3. **如果j--1，则将i和j分别加1，准备下一趟比较;**
3. 如果T中所有字符均比较完毕，则返回匹配的起始下标;否则返回-1;

```c
int kmp(char *s, char *t){
    int i = 0;
    int j = 0;
    int len_s = strlen(s);
    int len_t = strlen(t);
    int next[len_t + 1];
    get_next(t,next);
    while (i < len_s && j < len_t) {
        if (j == -1 || s[i] == t[j]){
            i++;
            j++;
        } else{
            j = next[j];
        }
    }
    if (j == len_t) return (i - j);
    else return -1;
}
```



### next数组代码

```c
void get_next(char *t,int next[]){
    int j = -1;
    int i = 0;
    next[0] = -1;
    while (i < strlen(t)){
        if (j == -1 || t[i] == t[j]) {
            i++;
            j++;
            next[i] = j;
        } else{
            j = next[j];
        }
    }
}
```



main函数调用：

```c
//
// Created by EImago on 2021/11/13.
//

#include <string.h>
#include <stdio.h>

void get_next(char *t,int next[]){
    int j = -1;
    int i = 0;
    next[0] = -1;
    while (i < strlen(t)){
        if (j == -1 || t[i] == t[j]) {
            i++;
            j++;
            next[i] = j;
        } else{
            j = next[j];
        }
    }
}

int kmp(char *s, char *t){
    int i = 0;
    int j = 0;
    int len_s = strlen(s);
    int len_t = strlen(t);
    int next[len_t + 1];
    get_next(t,next);
    while (i < len_s && j < len_t) {
        if (j == -1 || s[i] == t[j]){
            i++;
            j++;
        } else{
            j = next[j];
        }
    }
    if (j == len_t) return (i - j);
    else return -1;
}

int main(){
    char s[] = "abdacabcdabd";
    char t[] = "abcdabd";
    printf("%d ",kmp(s,t));
}
```

运行结果：![image-20211113195538025](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20211113195538025.png)





## 矩阵的压缩存储

### **特殊矩阵和稀疏矩阵**

- **特殊矩阵**：矩阵中很多值相同的元素并且它们的分布有一定的规律。
- **稀疏矩阵**：矩阵中有很多零元素。
- 压缩存储的基本思想是：
  - 为多个值**相同**的元素只分配**一个**存储空间;
  - 对零元素**不分配**存储空间。



### **对称矩阵**

![image-20211114155817396](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20211114155817396.png)

以对角线为中轴，矩阵的上半部分和下半部分是对称的。

特点：**a~ij~=a~ji~**



#### **对称矩阵的压缩存储**

对于这种矩阵，我们只存储下三角部分的元素。

![image-20211114160306851](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20211114160306851.png)

主要思想是把一个二维的下三角矩阵转换为一个一维数组，所以我们需要推导a~ij~在数组中的位置。



![image-20211114160647530](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20211114160647530.png)

在第一行有1个元素，第二行有2个元素，所以在第i-1行时就有i-1个元素，再加上列数j就得出了a~ij~在一维数组中的序号。

> a~ij~在一维数组中的序号=上图阴影部分的面积
> 									  =1+2+...+(i-1)+j
> 									  =**i×(i-1)/2+j**
>
> 在C语言中一维数组下标从0开始，所以a~ij~在一维数组中的下标
> 									**<font color='red'>k=i×(i-1)/2+j-1</font>**



![image-20211114161607186](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20211114161607186.png)

对于下三角中的元素a~ij~(i≥j)，在数组中的下标k与i、j的关系为：**<font color='red'>k=i×(i-1)/2+j -1</font>**。

上三角中的元素a~ij~(i<j)，因为a~ij~=a~ji~，则访问和它对应的元素a~ji~,即可，即：**<font color='red'>k=j×(j-1)/2+i-1</font>** 。



### **三角矩阵**

![image-20211114162118943](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20211114162118943.png)

下三角矩阵中，下三角存放的是任意值，上三角存放的是一个常数c。

![image-20211114162302483](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20211114162302483.png)

上三角矩阵中，上三角存放的是任意值，下三角存放的是一个常数c。



#### **下三角矩阵的压缩存储**

存储下三角元素，对角线上的常数只存一个

![image-20211114162723375](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20211114162723375.png)



矩阵中任一元素a~ij~，在数组中的下标k与i、j的对应关系为：

![image-20211114162845062](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20211114162845062.png)



#### **上三角矩阵的压缩存储**

存储上三角元素，对角线上方的常数只存一个

矩阵中任一元素a~ij~，在数组中的下标k与i、j的对应关系为：

![image-20211114163044087](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20211114163044087.png)



### **对角矩阵**

**对角矩阵**：所有非零元素都集中在以主对角线为中心的带状区域中，除了主对角线和它的上下方若干条对角线的元素外，所有其他元素都为零。

![image-20211114163222718](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20211114163222718.png)



#### **对角矩阵的压缩存储**

![image-20211114163851383](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20211114163851383.png)

![image-20211114163825918](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20211114163825918.png)

以矩阵A的a~43~元素为例，在矩阵第一行有2个元素，第一行到a~43~所在行的中间行每行有3个元素，所以a~43~所在行之前的元素总数为2+3(i-2)，再通过j-i+2的方式得到a~43~在当前行所在的位置。

> 元素a~ij~在一维数组中的序号=2+3(i-2)+(j-i+2)
> 											  =2i+j-2
>
> 因为一维数组下标从0开始，所以元素a~ij~在一维数组中的下标=**<font color='red'>2i+j-3</font>**



在日常工作中我们遇到的矩阵不一定都是这些类型的矩阵，我们要根据实际情况推导出矩阵的规律



### **稀疏矩阵的压缩存储**

![image-20211114164929439](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20211114164929439.png)

在稀疏矩阵中只存放很少的非零元素，我们只需要存储这些非零元素。

为了方便存储稀疏矩阵我们引入一个三元组：（行号，列号，非零元素值）

定义三元组：

```c
struct Triple {
    int row,col;	// 行号，列号
    DataType item;	//非零元素值
};
```

DataType为任意类型。

**三元组表**：将稀疏矩阵的非零元素对应的三元组所构成的集合，按行优先的顺序排列成一个线性表。
![image-20211114165448097](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20211114165448097.png)



#### **三元组顺序表**

采用顺序存储结构存储三元表

![image-20211114165720752](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20211114165720752.png)

 

![image-20211114170031212](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20211114170031212.png)

除了存储非零元素，我们还需要存储3个特殊值：非零元素个数、矩阵行数、矩阵列数。

那么，稀疏矩阵的修改操作就变成了三元组顺序表的插入/删除操作。

三元顺序表的结构定义：

```c
const int MAX=100;
struct SparseMatrix {
    struct Triple data[MAX];	// 存储非零元素
    int row,col,num;			// 行数、列数、非零元素个数
};
```

这种存储方法的**缺点**是：进行矩阵加法、减法等操作时，非零元素的个数和位置都会发生变化，顺序存储法就非常不方便了。



#### **十字链表**

采用链接存储结构存储三元组表，每个非零元素对应的三元组存储为一个链表结点，结构为：

![image-20211114170723338](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20211114170723338.png)

- row：存储非零元素的行号
- col：存储非零元素的列号
- item：存储非零元素的值
- right：指针域，指向同一行中的下一个三元组
- down：指针域，指向同一列中的下一个三元组



矩阵M用十字链表存储的结构为：

![image-20211114172030567](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20211114172030567.png)





## 树的逻辑结构

**树**：n (n≥0）个**结点**的有限**集合**。当n=0时，称为空树；任意一棵非空树满足以下条件:

1. 有且仅有一个特定的称为根的结点；
2. 当n>1时，除根结点之外的其余结点被分成m（m>0）个**互不相交**的有限集合T~1~, T~2~, ... ,T~m~，其中每个集合又是一棵树，并称为这个根结点的**子树**。

![image-20211117154655624](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20211117154655624.png)





### **树的基本概念**

- **结点的度**：结点所拥有的子树的个数。

- **树的度**：树中各结点度的最大值。

  ![image-20211117155049308](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20211117155049308.png)

- **叶子结点**：度为0的结点，也称为终端结点。

- **分支结点**：度不为0的结点，也称为非终端结点。

  ![image-20211117155231618](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20211117155231618.png)

  ​							上图中红颜色的结点为分支结点；黄颜色的结点为叶子节点（终端结点）。

- **孩子、双亲**：树中某结点子树的根结点称为这个结点的**孩子结点**，这个结点称为它孩子结点的**双亲结点**；

- **兄弟**：具有同一个双亲的孩子结点互称为兄弟。
                                        ![image-20211117155706991](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20211117155706991.png)

  ​										在上图中，对于B、E、F来说，B是E、F的双亲结点；E、F是B的孩子结点；E、F互为兄弟结点
  ​										对于D、H、I、J来说，D是H、I、J的双亲结点；H、I、J是D的孩子结点；H、I、J互为兄弟结点

- **路径**：如果树的结点序列n~1~,n~2~.,..., n~k~,有如下关系：结点n~i~是n~n+1~的双亲(1<=i<k)，则把n~1~,n~2~,...,n~k~,称为一条由n~1~,至n~k~的路径；路径上经过的边的个数称为**路径长度**。

  ![image-20211117160324221](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20211117160324221.png)

  ​	上图中，红色线段为A到L的路径，路径的长度为3。

- **祖先、子孙**：在树中，如果有一条路径从结点x到结点y,则x称为y的祖先，而y称为x的子孙。

  ![image-20211117160324221](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20211117160324221.png)

  ​		在上图中，A是L的祖先，L是A的子孙。

- **结点所在层数**：根结点的层数为1；对其余任何结点，若某结点在第k层，则其孩子结点在第k+1层。

- **树的深度**：树中所有结点的最大层数，也称**高度**。

  ![image-20211117160836548](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20211117160836548.png)

- **层序编号**：将树中结点按照从上层到下层、同层从左到右的次序依次给他们编以从1开始的连续自然数。

  ![image-20211117161000723](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20211117161000723.png)

- **有序树、无序树**：如果一棵树中结点的各子树从左到右是有次序的，称这棵树为有序树；反之，称为无序树。

- **森林**：m(m≥0)棵互不相交的树的集合。

  ![image-20211117161201657](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20211117161201657.png)



### **树结构和线性结构的比较**

| 线性结构                       | 树结构                         |
| ------------------------------ | ------------------------------ |
| 第一个数据元素，无前驱         | 根节点（只有一个），无双亲     |
| 最后一个数据元素，无后继       | 叶子结点（可以有多个），无孩子 |
| 其它数据元素一个前驱，一个后继 | 其他结点一个双亲，多个孩子     |
| 一对一                         | 一对多                         |



### **树的抽象数据类型定义**

树的应用很广泛，在不同的实际应用中，树的基本操作不尽相同。下面给出一个树的抽象数据类型定义的例子，简单起见，基本操作**只包含树的遍历**，针对具体应用，需要重新定义其基本操作。

- Data
  - 树是由一个根结点和若干棵子树构成，树中结点具有相同数据类型及层次关系
- Operation
  - InitTree
    - 前置条件：树不存在
    - 输入：无
    - 功能：初始化一棵树
    - 输出：无
    - 后置条件：构造一个空树
  - DestroyTree
    - 前置条件：树已存在
    - 输入：无
    - 功能：销毁一棵树
    - 输出：无
    - 后置条件：释放该树占用的存储空间
  - PreOrder
    - 前置条件：树已存在
    - 输入：无
    - 功能：前序遍历树
    - 输出：树的前序遍历序列
    - 后置条件：树保持不变
  - PostOrder
    - 前置条件：树已存在
    - 输入：无
    - 功能：后序遍历树
    - 输出：树的后序遍历序列
    - 后置条件：树保持不变



### **树的遍历操作**

**树的遍历**：从**根**结点出发，按照某种**次序访问**树中所有结点，使得每个结点被访问一次且仅被访问一次。

访问可以是对结点进行的各种处理，这里简化为输出结点的数据



#### **前序遍历**

若树为空，则空操作返回；

否则：

1. 访问根结点；
2. 按照从左到右的顺序前序遍历根结点的每一棵子树。

![image-20211117163936574](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20211117163936574.png)

前序遍历序列：A B D E H I F C G



#### **后序遍历**

若树为空，则空操作返回；

否则：

1. 按照从左到右的顺序后序遍历根结点的每一棵子树;
2. 访问根结点。

![image-20211117164229175](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20211117164229175.png)

后序遍历序列：D H I E F B G C A



#### **层序遍历**

从树的第一层（即根结点）开始，自上而下逐层遍历，在同一层中，按从左到右的顺序对结点逐个访问。

![image-20211117164449049](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20211117164449049.png)

层序遍历序列：A B C D E F G H I





## 树的存储结构

实现树的存储结构关键在于表示如何表示树种结点之间的逻辑关系，也就是如何表示结点的双亲和孩子。



### **双亲表示法**

**基本思想**：用一维数组来存储树的各个结点（一般按**层序**存储），数组中的一个元素对应树中的一个结点，包括结点的数据信息以及该结点的双亲在数组中的下标。

![image-20211118194829116](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20211118194829116.png)

**data**：存储树中结点的数据信息
**parent**：存储该结点的双亲在数组中的下标

```c
struct PNode{
    DataType data;	// 数据域
    int parent;		// 指针域，双亲在数组中的下标
};
```

我们创建一个一维数组，一维数组中的每个元素都是上面的结构体；data可以是任意类型。

树的双亲表示法实质上是一个静态链表，用一个一维数组来模拟链表结构。

<hr/>

![image-20211118212758320](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20211118212758320.png)

如上图所示，按层序遍历将树的结构存放在一维数组中，**data域存放树的结点信息**，**parent域存放当前结点的双亲结点在该数组中的下标**。如数组中的第一个元素，data域存放树的根节点A，而根节点没有双亲结点，所以parent域中存放的是-1；结点I的双亲结点是E在数组中的下标是4，所以它的parent域存放的值为4；

但是上面的存储结构并不完美，如果我们找的是当前结点的双亲结点，那么可以很快的找到。但是当我们要查找该结点的孩子结点时我们需要遍历整个数组。



![image-20211118200928763](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20211118200928763.png)

我们给这个结构体添加firstChild分量和rightSib分量。**firstChild存放该结点的第一个孩子结点**，**rightSib存放该结点的右兄弟结点**。如当我们要查找结点A的孩子结点时，发现A结点所在元素的firstChild存放的数为1，再查找数组中第1个元素的rightSib值为2，再查找数组中第2个元素的rightSib的值为-1，所以A结点的孩子结点为B、C。



### **孩子链表表示法**

链表中的每个结点包括一个数据域和多个指针域,每个指针域指向该结点的一个孩子结点。

#### **方案一：指针域的个数等于树的度**

![image-20211118202021267](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20211118202021267.png)

**data**：数据域，存放该结点的数据信息；
**child1~childn**：指针域，指向该结点的孩子。

![image-20211118202732137](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20211118202732137.png)

如上图中，树的度为3，所以结构体中有3个指针域，指向自己的孩子结点，当结点的度小于3时，多余的指针域为NULL。

这种方案比较直观，但**缺点是会浪费一些存储空间**，如叶子结点的指针域都为NULL。



#### **方案二：指针域的个数等于该结点的度**

![image-20211118203411262](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20211118203411262.png)

**data**：数据域，存放该结点的数据信息；
**degree**：度域，存放该结点的度；
**child1~childn**：指针域，指向该结点的孩子。

![image-20211118203759617](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20211118203759617.png)

如上图中，结点A的度为2，所以有2个指针域；结点I的度为0，所以没有指针域。

但是这种方案的**缺点在于结点的结构是不一致的**，需要构建非常多的结构体。



#### **方案三：将结点的所有孩子放在一起，构成线性表**

**孩子链表的基本思想**：把每个结点的孩子排列起来，看成是一个线性表，且以单链表存储，则n个结点共有n个孩子链表。这n个单链表共有n个头指针，这n个头指针又组成了一个线性表，为了便于进行查找采用顺序存储。最后，将存放n个头指针的数组和存放n个结点的数组结合起来，构成孩子链表的表头数组。

![image-20211118204317317](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20211118204317317.png)

```c
struct CTNode{
    int child;	// 整数型孩子
    CTNode *next;	// 指向这个结点的指针
};
```

![image-20211118204415139](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20211118204415139.png)

```c
struct CBNode{
    DataType data;	// 结点的基本信息
    CTNode *firstChild;	// 第一个孩子结点
};
```



![image-20211118205802975](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20211118205802975.png)

CTNode的指针域指向兄弟结点，CBNode的指针域指向孩子结点。

在上图中，用**表头结点**（CBNode）构成一个结构体数组，data域存放结点的基本信息，firstChild域指向该结点的第一个孩子结点。如，树的根节点A在数组中的第0个位置，该位置的data域存放字符A，firstChild域指向A结点的第一个**孩子结点**（CTNode）B，它在数组中是第1个位置，所以**孩子结点**（CTNode）的child域存放的是B在数组中的位置1。以此类推，当表头结点没有孩子结点 或者 孩子结点没有兄弟结点时指针域为NULL。

使用这种存储结构的**缺点是查找双亲结点时需要耗费大量的时间**。我们在上面的数组中添加parent字段就有了双亲孩子表示法。



### **双亲孩子表示法**

![image-20211118210824094](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20211118210824094.png)



在CBNode结构体中添加parent域，存放该节点的双亲结点的下标。



### **孩子兄弟表示法**

这种表示法的依据在于：某结点的第一个孩子是惟一的某结点的右兄弟是惟一的。

设置两个分别指向该结点的第一个孩子和右兄弟的指针。

![image-20211118211139149](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20211118211139149.png)

data：数据域，存储该结点的数据信息；
firstChild：指针域,指向该结点第一个孩子；
rightSib：指针域，指向该结点的右兄弟结点。

```c
struct TNode{
    DataType data;
    TNode *firstChild,*rightSib;
};
```

![image-20211118211829832](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20211118211829832.png)

在上图中，结点A的第一个孩子为结点B，所以结点AdefirstChild域指向结点B，结点A没有右兄弟，所以rightSib为空；结点B的第一个孩子结点为D，所以B的firstChild域指向结点D，D的有兄弟结点为E，所以rightSib域指向结点E。以此类推。

 

## 二叉树的逻辑结构

### **二叉树的定义**

**二叉树**是n(n≥0)个结点的有限集合，该集合或者为空集（称为空二叉树)，或者由一个根结点和两棵互不相交的、分别称为根结点的左子树和右子树的二叉树组成。

研究二叉树的意义在于将树转换为二叉树，从而解决树的相关问题。



### **二叉树的特点**

1. 每个结点最多有两棵子树；
2. 二叉树是有序的，其次序不能任意颠倒。

![image-20211120152149360](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20211120152149360.png)

要注意，二叉树和树是两种树结构。



### **二叉树的基本形态**

![image-20211120152329552](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20211120152329552.png)





### **特殊的二叉树**

#### **斜树**

1. 所有结点都只有左子树的二叉树称为**左斜树**;
2. 所有结点都只有右子树的二叉树称为右斜树;
3. 左斜树和右斜树统称为**斜树**。

![image-20211120152515363](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20211120152515363.png)

**斜树的特点**

- 在斜树中，每一层只有一个结点;
- 斜树的结点个数与其深度相同。



#### **满二叉树**

在一棵二叉树中，如果所有分支结点都存在左子树和右子树，并且所有叶子都在同一层上。

![image-20211120152713537](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20211120152713537.png)

**满二叉树的特点**

- 叶子只能出现在最下一层
- 只有度为0和度为2的结点
- 满二叉树在同样深度的二叉树中结点个数最多
- 满二叉树在同样深度的二叉树中叶子结点个数最多



Q：下图中的树是满二叉树吗？
![image-20211120152932941](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20211120152932941.png)

A：不是满二叉树,虽然所有分支结点都有左右子树，但叶子不在同一层上!



#### **完全二叉树**

对一棵具有n个结点的二叉树按层序编号，如果编号为i（1<i<n）的结点与同样深度的满二叉树中编号为i的结点在二叉树中的位置完全相同。

![image-20211120153432749](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20211120153432749.png)

完全二叉树的编号方式和满二叉树的编号方式完全相同，如上图中上半部分是满二叉树，下半部分是完全二叉树；在满二叉树中，从最后一个结点开始，**<font color='red'>连续</font>**去掉**<font color='red'>任意</font>**个结点，即是一棵完全二叉树。

**完全二叉树的特点**

- 叶子结点只能出现在最下两层且最下层的叶子结点都集中在二叉树的左面
- 完全二叉树中如果有度为1的结点，只可能有一个，且该结点只有左孩子
- 深度为k的完全二叉树在k-1层上一定是满二叉树
- 在同样结点个数的二叉树中,完全二叉树的深度最小

<iframe src="//player.bilibili.com/player.html?aid=840059140&bvid=BV1Z54y1R7Kt&cid=172533036&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="width:100%;height:450px;"> </iframe>



### **二叉树的基本性质**

1. **二叉树的第i层上最多有2^i-1^个结点（i≥1)** 。
2. **一棵深度为k的二叉树中，最多有2^k^-1个结点，最少有k个结点**。
3. **在一棵二叉树中，如果叶子结点数为n~0~，度为2的结点数为n~2~，则有:n~0~=n~2~+1**。
4. **具有n个结点的完全二叉树的深度为⌊Log~2~n⌋+1**。
5. 对一棵具有n个结点的完全二叉树中从1开始按层序编号，则对于任意的序号为i （1≤i≤n）的结点(简称为结点i)，有：
   1. **如果i>1，则结点i的双亲结点的序号为i/2；如果i=1，则结点i是根结点，无双亲结点**。
   2. **如果2i≤n，则结点i的左孩子的序号为2i；如果2i>n，则结点i无左孩子。**
   3. **如果2i+1≤n，则结点i的右孩子的序号为2i+1；如果2i+1>n，则结点i无右孩子**。

<iframe src="//player.bilibili.com/player.html?aid=455049113&bvid=BV1D541167LF&cid=172666187&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="width:100%;height:450px;"> </iframe>



## 二叉树的存储结构

### **顺序存储结构**

二叉树的顺序存储结构就是用一维数组存储二叉树中的结点，并且结点的**存储位置**（下标）应能体现结点之间的**逻辑关系**——父子关系。

**完全二叉树**和**满二叉树**中结点的序号就可以唯一地反映出结点之间的逻辑关系。

![image-20211120183153314](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20211120183153314.png)

按层序遍历给树的每个结点编号，一编号为下标存储在一维数组中。

![image-20211120183410566](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20211120183410566.png)

编号时需要注意**按完全二叉树编号**；将上图中的二叉树以编号为下标存储在一维数组中的结构如下图所示

![image-20211120183558233](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20211120183558233.png)

由于在C语言中数组的下标从0开始，也可以将编号为i的结点存储到下标为i-1的位置。

![image-20211120183825753](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20211120183825753.png)

> Q：一棵斜树的顺序存储会怎样？
>
> A：深度为k的右斜树，k个结点需分配2^k^-1个存储单元。
>
> ![image-20211120184038335](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20211120184038335.png)
>
> ​	一棵二叉树改造后成完全二叉树形态，需增加很多空结点，**造成存储空间的浪费**。

二叉树的顺序存储结构**一般仅存储完全二叉树**。



### **二叉链表**

**基本思想**：令二叉树的每个结点对应一个链表结点，链表结点除了存放与二叉树结点有关的数据信息外，还要设置指示左右孩子的指针。

![image-20211120184250701](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20211120184250701.png)

**data**：数据域，存放该结点的数据信息
**lchild**：左指针域，存放指向左孩子的指针
**rchild**右指针域，存放指向右孩子的指针

```c
struct BiNode{
    DataType data;
    BiNode *lchild,*rchild;
};
```

![image-20211120184744367](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20211120184744367.png)

如上图中，data域存放的是结点字符名称，在实际开发过程中可能存放的是非常复杂的数据类型；B结点的左孩子是D结点，所以B结点的lchild指向的是D结点，而B结点没有右孩子，所以rchild为空。

> Q：具有n个结点的二叉链表中，有多少个空指针?
>
> A：具有n个结点的二叉链表中，有n+1个空指针。



### **三叉链表**

使用二叉链表是要想找到某个结点的双亲结点就比较复杂；为了方便的查找双亲结点，在二叉链表的基础上增加了一个指向双亲的指针域形成三叉链表。

![image-20211120185513634](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20211120185513634.png)

其中: data、lchild和rchild三个域的含义同二叉链表的结点结构；parent域为指向该结点的双亲结点的指针。

![image-20211120185754654](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20211120185754654.png)



#### **三叉链表的静态链表形式**

![image-20211120190121349](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20211120190121349.png)

用结构体数组来存放二叉树，数组每个元素的结构域上面的三叉链表结构一致，将结点的下标存储在结构体对应的分量中，当某节点的双亲或孩子结点不存在时存入-1。

但是这种静态链表形式存储的**缺点在于当需要删除、添加结点时需要移动大量元素**，所以这种存储方式一般存储不太需要改动的二叉树。



<iframe src="//player.bilibili.com/player.html?aid=200049485&bvid=BV1Gz411b7Rq&cid=172819065&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="width:100%;height:500px"> </iframe>



## 二叉树的遍历

二叉树的遍历是指从根结点出发，按照某种次序访问二叉树中的所有结点，使得每个结点被访问一次且仅被访问一次。

在这里我们将访问结点简化为输出结点的数据。

- 二叉树
  - 根节点：D
  - 左子树：L
  - 右子树：R

前序：DLR
中序：LDR
后序：LRD
层序：按二叉树的层序编号的次序访问各结点。



### **前序遍历**

若二叉树为空，则空操作返回；

否则：

1. 访问根结点；
2. 前序遍历根结点的左子树；
3. 前序遍历根节点的右子树；

![image-20211120194455962](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20211120194455962.png)

上图中，前序遍历序列为：A B D G C E F

**前序遍历递归算法**：

```c
void PreOrder(BiNode *root){
    if (root){
        Visit(root->data);		// 访问根结点
        PreOrder(root->lchild);	// 先序遍历左子树
        PreOrder(root->rchild);	// 先序遍历右子树
    }
}
```



### **中序遍历**

若二叉树为空，则空操作返回；

否则：

1. 中序遍历根结点的左子树
2. 访问根结点
3. 中序遍历根结点的右子树

![image-20211120195214089](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20211120195214089.png)

上图中，中序遍历序列为：D G B A E C F

**中序遍历递归算法**：

```c
void InOrder(BiNode *root){
    if (root){
        InOrder(root->lchild);	// 中序遍历左子树
        Visit(root->data);		// 访问根结点
        InOrder(root->rchild);	// 中序遍历右子树
    }
}
```



### **后序遍历**

若二叉树为空，则空操作返回；

否则：

1. 后序遍历根节点的左子树
2. 后序遍历根结点的右子树
3. 访问根节点

![image-20211120195214089](https://eimago.oss-cn-beijing.aliyuncs.com/typora-img/image-20211120195214089.png)

上图中，后序遍历序列为：G D B E F C A

**后序遍历递归算法**：

```c
void PostOrder(BiNode *root){
    if (root){
        PostOrder(root->lchild);	// 后序遍历左子树
        PostOrder(root->rchild);	// 后序遍历右子树
        Visit(root->data);			// 访问根结点
    }
}
```



### **层序遍历**

对层序遍历编程我们需要使用一个队列

**伪代码**：

1. 队列Q初始化；
2. 如果二叉树非空，将根指针入队；
3. 循环直到队列Q为空
   1. q=队列Q的队头元素出队；
   2. 访问结点q的数据域；
   3. 若结点q存在左孩子，则将左孩子指针入队；
   4. 若结点q存在右孩子，则将右孩子指针入队；

**层序遍历算法**：

```c
void LeverOrder(BiNode *root){
    if (root) {
        BiNode q;
        link_queue_ptr queue = init_link_queue();	// 初始化队列
        in_link_queue(queue,root);	// 入队列
        while(!is_empty_link_queue(root)){
            out_link_queue(queue,&q);	// 出队列
            Visit(q->data);
            if (q->lchild != NULL)	in_link_queue(queue,q->lchild);	// 左孩子入队
            if (q->rchild != NULL)	in_link_queue(queue,q->rchild);	// y孩子入队
        }
    }
}
```



<iframe src="//player.bilibili.com/player.html?aid=412565009&bvid=BV1qV411f77r&cid=172910194&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="width:100%;height:500px"> </iframe>

